# Java中的逃逸分析
- https://segmentfault.com/a/1190000016803174
- https://cloud.tencent.com/developer/article/1470945

## 问题
- JVM会将class文件转成机器码
- 即时编译技术 JIT 解决了这种转换慢的问题
- JIT 缓存了最近使用的机器码
- JIT 优化了代码编译

## 逃逸分析
- 逃逸分析只的是对Java对象动态作用域的分析
- 方法逃逸，对象定义后，对外部对象引用
- 线程逃逸，对象创建后，被其他方法或者线程引用
- 函数内定义的对象，不应返回到调用者

## 同步省略
- 经过逃逸分析，对象不会被多线程访问，即时编译会省略同步措施，即锁消除
- Vector 和 StringBuffer 虽然有所，但是在线程安全的代码中，即时编译会消除锁

## 标量替换
- 标量，Scalar，原始数据类型
- 聚合量，Aggregate，Java对象
- 经过逃逸分析，没有线程逃逸，即时编译会把对象创建拆分成标量创建
- 标量替换减少了堆内存的使用，基本类型都在栈上，不需要GC

## 栈上分析
- 如何让对象创建在栈上？
- HotSpot JVM没有实现栈上分配，实际用标量替换来实现

## 如何开启分析
- JDK 1.7 后默认打开
- -XX:+DoEscapeAnalysis
- -XX:-DoEscapeAnalysis
