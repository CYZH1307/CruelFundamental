#### mutex的实现和局限性

##### 实现：

不管是自旋锁还是互斥锁，都基于底层的原子操作建立逻辑，即原子的“compare and set”操作，相当于一个函数 CAS(a,b,c)，a==b则把c赋值给a，返回true，否则返回false，同时这个函数不会被打断。这里尝试简单的演示一下实现

```c++
class Mutex
{
    int m;
    Mutex():m(0){}
    void Lock()
    {
        while(!CAS(m,0,1))
        {
            if(1)
            continue;//自旋锁
            else
            sleep();//互斥锁
        }
    }
    void Unlock()
    {
        m=0;//感觉应该可以直接赋值
    }
};
```

##### 和自旋锁比较：

其实就是没有获得锁后决策的差异，自旋锁不停的判断能否获得锁，互斥锁则让这个线程睡眠等到锁没有被占用再放到就绪队列。所以互斥锁比自旋锁多了切换上下文的开销，应该要看具体的场景进行选择。