How to generate the global increasing id?

In SQL, we can create the table

CREATE TABLE example (
 primary_key AUTOINCREMENT PRIMARY KEY,
 ...
);

In Oracle, we can use sequence while inserting in the table

CREATE SEQUENCE seq_example
MINVALUE 1
START WITH 1
INCREMENT BY 1
CACHE 10;
INSERT INTO example (primary_key)
VALUES (seq_example.nextval);


In distributed environment, there’s a couple of the approaches:


Database Ticket servers: These are the centralized auto increment servers which response with ids when requested from nodes. The problem with these kinds of nodes is a single point of failure.


UUID: UUIDs are 128-bit hex numbers that are globally unique. The chances of the same UUID getting generated twice is negligible. There’s very less possibility for collision. 

UUID contains a reference to the network address of the host that generated the UUID, a timestamp (a record of the precise time of a transaction), and some randomly generated component.

UUID’ s does not require coordination between different nodes and can be generated independently.

But the problem with UUID is very big in size and does not index well so while indexing it will take more size which effects query performance.


Twitter SnowFlake: Twitter snowflake is a dedicated network service for generating 64-bit unique IDs at high scale with some simple guarantees.

Components:
Epoch timestamp in millisecond precision — 41 bits (gives us 69 years with a custom epoch)
Machine id — 10 bits (gives us up to 1024 machines)
Sequence number — 12 bits (A local counter per machine that rolls over every 4096)
The extra 1 bit is reserved for future purposes.

The id which is generated by this is 64bit which solves the problems of size and latency issues but also introduces one problem for maintaining extra servers.


