
### 进程、线程、协程的区别和联系：

Reference: https://zhuanlan.zhihu.com/p/344823347, https://zhuanlan.zhihu.com/p/79772089

#### 进程

- 资源分配的基本单位，
- 包括可执行的代码、打开的文件描述符、挂起的信号、进程的状态、内存地址空间、存放全局变量的数据段，以及一个或多个执行线程等

#### 线程

- 进程中活动的对象，独立调度的基本单位
- 拥有**独立的程序计数器、线程堆栈和寄存器**
- **共享内存地址空间、代码段、全局变量、打开文件集合**
- Linux中创建线程会在执行 `clone()` 的时候传递一些参数来指明需要共享的资源。

---

#### 进程线程的联系：

- 进程是资源的容器，用来把资源集中到一起，而线程是在 CPU 上被实际调度的实体对象。
- 进程中有很多task，若只有一个调度，则当某个task被阻塞，其他task就不得不到执行，因此需要更多独立调度的单元 => 这些单元就是线程
- 线程比进程更轻量，创建、撤销、切换更快。
  - 进程上下文切换开销：1. 切换页表全局目录；2.切换内核态对战；3. 切换硬件上下文 （进程恢复前必须装入寄存器的数据，如 instruction pointer, base pointer, stack pointer, cr3 (页目录基址寄存器，保存页目录表的物理地址)）；4. 刷新 TLB；系统调度器的代码执行
  - 线程上下文切换开销：在 Linux 中，并不太区分进程和线程，线程只是一种轻量级进程。他们都有自己独立的task_struct进程描述符，也都有自己独立的pid。其与普通进程的区别是可以共享同一内存地址空间、代码段、全局变量、同一打开文件集合。它们的创建方式也大致相同，都是调用 fork() 函数，然后底层执行 clone() 方法创建。

---

#### 协程

- 大量并发应使用协程，而非线程

- 用户态的轻量级线程。协程不是操作系统的机制，而是由用户程序自身控制的一种调度
- 创建开销非常小，栈空间占用只有2k~4k，在一个地址空间中可以运行 10w 级别的协程。
- 相比于进程和线程的上下文切换，协程几乎没有切换的开销，因为协程的调度完全由用户程序控制，只需要保存任务的上下文，不涉及内核资源的保存和恢复。

- 在 Go 语言中，协程的栈数量可以动态伸缩，不会出现栈溢出，当一个协程结束时会自动释放，不需要垃圾回收器管理。多个协程之间的同步是通过 channel 实现的，可以保证协程执行的顺序，因此不需要锁机制就可以实现安全的并发。

