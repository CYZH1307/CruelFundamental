什么是索引
索引是存储引擎用于快速找到记录的一种数据结构,这是索引的基本功能，相当于字典目录。索引对于良性的性能非常关键,尤其是当表中的数据量越来越大时,索引对性能的影响愈发重要。在数据较小且负载较低时,不恰当的索引对性能的影响可能还不明显,但当数据量逐漸增大时,不恰当的索引会使性能急剧下降
索引类型
索引有很多种类型,可以为不同的场景提供更好的性能。在 MYSQL中,索引是在存储引擎层而不是服务器层实现的。所以,并没有统一的索引标准:不同存储引擎的索引的工作方式并不一样,也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引,其底层的实现也可能不同。造成这些的原因就是索引是存储在引擎层中
Hash索引
哈希索引( Hash Index)基于哈希表实现,只有精确匹配索引所有列的查询才有效。对于每一行数据存储引都会对所有的索引列计算一个哈希码( Hash Code),哈希码是一个较小的值。哈希索引将哈希码存储在索引中,同时在哈希表中保存指向每个数据行的指针(索引列的值的哈希 +每行数据的行号指针)
因为哈希索引自身只需存储对应的哈希值,所以索引的结构十分紧湊,这也让哈希索引查找的速度非常快,然而哈希索引也有它的限制，目前Mysql中只有Memory引擎支持Hash索引，其他的建立Hash保存也会失效

- 哈希索引只包含哈希值和行指针,而不存储字段值,所以不能使用索引中的值来避免读取行
Hash索引在硬盘中会有一张实际的表与之对应，行指针指向的就是哈希值在对应表中的行地址。在BTree索引中，如果查询返回的结果被包含在索引列之中，可以避免去读取行，直接读索引可以大大的提高执行的效率。但是Hash索引上储存的是哈希码值是无法解开还原的。
- 哈希索引数据井不是按照索引值顺序存储的,所以也就无法用于排序
由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算;
- 哈希索引只有精确匹配索引所有列的查询才有效，不支持部分索引列匹配查找
哈希索引保存的是索引列的值组合后的哈希码，例如inx_demo_group1(first_name, age, last__name)组合索引，索引保存的就是first_name+age+last__name 的哈希值和数据行指针，如果WHERE只使用其中first_name+age，很显然first_name+age的结果和索引上的哈希值关联不起来。所以Hash索引需要把索引所有的列使用起来才能生效
- 哈希索引只支持等值比较,包括=、in0、<=>,也不支持任何范围查询
由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。
- 访问哈希索引的数据非常快,除非有很多哈希冲突
哈希的计算效率和检索速度只需要一次计算就能定位到数据的位置，但如果哈希冲突，就需要去遍历链表，链表越长，性能越低
- 如果哈希冲突很多的话,一些索引维护操作的代价也会很高



聚簇索引和非聚簇索引

聚簇索引是一种数据存储方式，因为是储存引擎负责实现索引，所以不是所有的存储引擎都支持聚簇索引。B+Tree结构都可以用在MyISAM和InnoDB上，InnoDB使用的是聚簇索引，MyISAM的是非聚簇索引

聚簇索引

InnoDB通过主键聚集数据，如果表没有定义主键，InnoDB会选择一个唯一的非空索引替代，如果也没有这样的索引，InnoDB会隐式定义一个主键来作为表的聚簇索引。



将主键组织到一棵B+树中，聚集索引就是表，叶子节点data域保存了完整的数据记录。若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对name列进行条件搜索，则需要两个步骤：第一步在二级索引（inx_demo(name）B+树中检索name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。
聚集索引的优点：
　　A：可以把相关数据保存在一起，如：实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户全部邮件，如果没有使用聚集索引，则每封邮件都可能导致一次磁盘IO
　　B：数据访问更快，聚集索引将索引和数据保存在同一个btree中，因此从聚集索引中获取数据通常比在非聚集索引中查找要快
　　C：使用覆盖索引扫描的查询可以直接使用页节点中的主键值
聚集索引的缺点：
　　A：聚簇数据最大限度地提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚集索引也没有什么优势了
　　B：插入速度严重依赖于插入顺序，按照主键的顺序插入是加载数据到innodb表中速度最快的方式，但如果不是按照主键顺序加载数据，那么在加载完成后最好使用optimize table命令重新组织一下表
　　C：更新聚集索引列的代价很高，因为会强制innodb将每个被更新的行移动到新的位置
　　D：基于聚集索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题，当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的磁盘空间
　　E：聚集索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候
　　F：二级索引可能比想象的更大，因为在二级索引的叶子节点包含了引用行的主键列。
　　G：二级索引访问需要两次索引查找，而不是一次
　 推荐使用主键自增来作为聚集索引，因为BTree树上主键的值是顺序的，所Innodb把每一条记录都存储在上一条记录（key大小排序）的后面，当达到页的最大填充因子时（innodb默认的最大填充因子是页大小的十六分之十五，留出部分空间用于以后修改），下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近似被顺序的记录填满
　　但是在UUID主键下，因为新插入行的主键值不一定比前面的大，所以innodb无法简单地总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置，通常是已有数据的中间位置，例如一个页中存储两个两个分别为17,19的主键数据，新插入的key =1818，那么key=18的数据必须存放在key = 17的后面，如果这个时候页大小不够储存key = 18 的数据，就需要分配新的空间，再将key = 19 数据移动到新空间中。这会增加很多额外的工作，并导致数据分布不够连续，下面是使用UUID作为主键的一些缺点：
A：写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，innodb在插入前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO
B：因为写入是乱序的，innodb不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入最少需要修改三个页不是一个页
C：由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片，导致IO读取性能下降
把这些随机值载入到聚集索引之后，也许需要做一次optimize table来重建表并优化页的填充。使用innodb时应该尽可能地按照主键顺序插入数据，并且尽可能地使用简单增加的聚簇键的值来插入新行。