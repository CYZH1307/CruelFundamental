# New features introduces into C++ 11

## auto & decltype

关于C++11新特性，最先提到的肯定是类型推导，C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。

## 右值引用

C++11新增了右值引用，这里涉及到很多概念：

* 左值：可以取地址并且有名字的东西就是左值。
* 右值：不能取地址的没有名字的东西就是右值。
* 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。
* 将亡值：可以理解为即将要销毁的值。
* 左值引用：对左值进行引用的类型。
* 右值引用：对右值进行引用的类型。
* 移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。
* 完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。
* 返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。

## 列表初始化

在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化

## std::function & std::bind & lambda表达式

C++11新增了std::function、std::bind、lambda表达式等封装使函数调用更加方便

## 模板的改进

C++11关于模板有一些细节的改进：

模板的右尖括号 模板的别名 函数模板的默认模板参数

## 并发

C++11关于并发引入了：

* std::thread相关
* std::mutex相关
* std::lock相关
* std::atomic相关
* std::call_once相关
* volatile相关
* std::condition_variable相关
* std::future相关
* async相关

## 智能指针

c++11引入了三种智能指针：

* std::shared_ptr
* std::weak_ptr
* std::unique_ptr

## explicit

explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，

## constexpr

constexpr constexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：

两者都代表可读，const只表示read-only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。