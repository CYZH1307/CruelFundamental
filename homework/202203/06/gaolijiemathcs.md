### mutex的实现和局限性

mutex为互斥体，指的是可以实现互斥的睡眠锁。例如类似使用计数为1的信号量，但操作更为高效，使用限制更多。

#### 使用方式

```
mutex_lock(&mutex)
/*临界区*/
mutex_unlock(&mutex)
```

#### 实现

需要实现如下的方法

| 方法                          | 描述                                                        |
| ----------------------------- | ----------------------------------------------------------- |
| mutex_init(struct mutex)      | 动态初始化mutex                                             |
| mutex_lock(struct mutex)      | 为指定的mutex上锁,如果锁不可用则睡眠(sleep)。               |
| mutex_unlock(struct mutex)    | 为指定的mutex解锁                                           |
| mutex_trylock(struct mutex)   | 试图获取指定的mutex，成功获取锁返回1，否则锁已被获取返回0。 |
| mutex_is_locked(struct mutex) | 查询锁状态，如果锁已被争用，返回1，否则返回0。              |



#### 局限性

mutex的使用场景更加严格。

- 任何时刻最多只由一个任务可以持有mutex。
- 给mutex上锁者必须负责将其解锁，不能在一个上下文中锁定一个mutex而在另外一个上下文解锁，不适合在内核同用户空间负责的同步场景。最常用的方式：同一上下文中上锁解锁。
- 递归上锁和解锁不允许，不能递归持有同一个锁，不能去解开一个已经被解锁的mutex。
- 当持有一个mutex时，进程不能退出.
- mutex不能在中断中使用。
- mutex只能用官方API管理：不能被拷贝、手动初始化/重复初始化。
- 自旋锁(spin lock)和互斥锁(mutex)的区别：自旋锁不会引发调用者睡眠，自旋锁会一直循环查询目标自旋锁是不是被释放了，进程会busy-waiting不停的请求锁。互斥锁，进程拿不到临界区的锁，就会将线程睡眠阻塞放入等待队列，为sleep-waiting(等待进程所在内核会进行上下文切换)。
- 建议长期加锁/持有锁后其他线程应该睡眠的场景，可以优先使用互斥体；短期开销加锁，短期锁定，或在中断上下文中加锁，应该使用自旋锁。

