# Java: JVM垃圾回收的原理，GC排查步骤。

## JVM垃圾回收原理

### 1 判断堆上对象存活算法

#### 1、引用计数法

（1）算法步骤

给堆上的对象添加一个引用计数器，每当有一个地方引用他的时候，计数器数值就加1；当引用失败的时候，计数器值就减1；任何时候计数器为0的对象就是不可能再被使用的。

（2）应用情况

实现简单，但是主流Java虚拟机都没有采用这种方法，难以解决循环引用的问题，并且维护引用计数器需要引入很多的额外处理。因此基本不用这种方法判定堆上对象存活情况。

#### 2、根搜索算法(GC Root可达性分析)

（1）算法步骤

以一系列叫"GC Roots"的根对象为起始结点，从这些结点开始，根据引用关系向下搜索，搜索过程路径称为"引用链"，当一个对象到GC Root之间没有任何引用链相连，图论当中称为从GC Roots到那些对象都不可达，则证明此对象不可能再被使用。

（2）可以作为GC Roots对象包括以下几种

- 虚拟机栈（栈帧当中的本地变量表）中的引用对象。
- 方法区中的静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中Native方法(JNI)引用对象。
- Java虚拟机内部引用、系统类加载器。
- 被同步锁持有的对象。

### 2 垃圾收集算法

#### 1、分代收集理论

（1）算法步骤

设计者将Java堆分为新生代和老年代，这样可以根据各个年代的特点采用适当的收集算法，在新生代中，每次垃圾收集的时候都会有大批对象死去，推荐使用复制算法，老年代对象存活率

```
分代假说：
(1)弱分代假说：绝大多数对象都是朝生夕灭的。
(2)强分代假说：熬过越多次垃圾收集过程的对象越难消亡。
(3)跨代引用假说：跨代引用相对于同代引用占少数。
奠定了基本设计原则：收集器按照Java堆划分出不同的区域，按照回收对象的年龄(熬过垃圾回收的次数)分配到不同区域存储，进行分区域后, 依照不同分代采用合适的收集算法，进行垃圾回收。
```

（2）分类

```
1、Partial GC: 部分分代收集，指目标不是完整收集整个Java堆的垃圾收集，其中分为:
	(1)新生代收集(Minor GC/Young GC): 目标只是新生代的垃圾收集
	(2)老年代收集(Major GC/Old GC): 目标只是老年代的手机。【CMS收集器才有】
	(3)混合收集(Mixed GC): 目标是收集整个新生代以及部分老年代的垃圾收集。【G1收集器才有】
2、Full GC: 整堆收集，收集整个Java堆和方法区的收集器。
```



#### 2、标记-清除算法

（1）算法步骤

①标记：首先标记处需要回收的对象。

②清除：标记完成后，统一回收掉所有被标记的对象。

注：也可以标记存活对象，统一回收没有被标记的对象。

（2）缺点

①运行效率不稳定：如果Java堆中包含大量对象需要被回收，这时候要做大量的标记清除动作，标记清除动作随着对象数量增加而降低。

②内存碎片化问题：标记清除，会产生大量不连续的内存碎片，碎片过多，导致大对象无法找到连续内存，不得不触发另一次垃圾回收动作。

（3）适用场景：一般用于老年代。



#### 3、标记-复制算法

（1）算法步骤

将内存区域分为两块，每次只使用其中的一块，这一块使用的内存用完了，就将还存活的对象赋值到另外一块上面，将已经使用的一块内存整块清除。【触发GC，就将一块内存的存活对象复制到另外一块上，清除使用的一块】。

（2）优缺点

优点：分配内存的时候，不需要考虑空间碎片复杂的情况，只需要移动堆顶指针，按顺序分配即可。

缺点：将内存缩小为原来的一半，代价太大。并且在对象存活率较高的情况还需要进行较多的复制。

（3）适用场景：一般用于新生代。

复制分代策略：

新生代：分为较大的Eden空间(80%)，和两块较小的Survivor空间(10%+10%)。发生垃圾回收的时候，将Eden和其中一块Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清除Eden和已经用过的Survivor空间。【这样实际上是新生代90%的空间用于内存分配，只有10%的空间被"浪费"】

老年代：当新生代的Survivor空间不足以容纳一次Minor GC的对象的时候，就需要依赖分配担保机制，直接进入老年代进行分配。



#### 4、标记-整理算法：

（1）算法步骤

①标记：将需要回收的对象标记。

②整理：将存活的对象统一移动到空间另外一端，清除在对象边界外的内存。

注：也可以标记存活不回收的对象，然后将存活对象统一移动到空间另外一端。

（2）优缺点：

优点：整理移动存活对象后可以解决内存碎片问题。

缺点：整理移动存活对象，是一种有开销的操作，并且需要暂停用户应用程序较长时间。【标记清除停顿时间短】

（3）适用场景：一般用于老年代。



## GC排查步骤

https://blog.csdn.net/weixin_38004638/article/details/106135505

### 1. 清楚从程序角度，有哪些原因导致FGC？ 

- 大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。

- 内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.
- 程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）
- 程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.
- 代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。
- JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。

### 2. 清楚排查问题时能使用哪些工具

- 公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。


- JDK的自带工具，包括jmap、jstat等常用命令：

  ```
  查看堆内存各区域的使用率以及GC情况
  
  jstat -gcutil -h20 pid 1000
  
  查看堆内存中的存活对象，并按空间排序
  
  jmap -histo pid | head -n20
  
  dump堆内存文件
  
  jmap -dump:format=b,file=heap pid
  ```

- 可视化的堆内存分析工具：JVisualVM、MAT等

### 3. 查看gc情况命令

查看某个进程的对象占用对象最大情况

```
// pid是进程号，20表示排名前二十，instances表示实例数量，bytes表示占用内存大小
jmap -histo pid | head -n 20
```

监控jvm内存，查看full gc频率

```
//监控jvm，每5秒打印一次，循环100次
jstat -gc pid 5000 100
```

### 4.排查指南

- 查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）
- 了解该时间点之前有没有程序上线、基础组件升级等情况。
- 了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。
- 再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。
- 针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。
- 通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。
  