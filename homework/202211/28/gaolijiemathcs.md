## 什么是缓存击穿, 穿透, 雪崩? 如何解决?

### 缓存雪崩

1、概念：当Redis缓存大量缓存Key集中在某一个时间段失效，所有的请求落库，导致数据库无法承受这么大的流量，将数据库打挂了，这个时候立刻重启数据库，数据库又被打挂。就是缓存雪崩，缓存失效，导致流量压坏数据库。如果打挂的是一个用户服务的库，很有可能其他依赖库的接口都报错了，如果没做熔断，基本上就是挂一片数据库。

2、解决方案：

- 方法一：批量向Redis存数据的时候，将每个Key的过期时间，都加一个随机值，确保数据不会在同一时间大面积失效。

  ```
  setRedis(Key, value, time + Math.random() * 10000);
  ```

- 方法二：如果Redis为集群部署，将热点数据均匀分散在不同的Redis库中也可以避免全部失效。但是生产环境中有可能是按照单个服务进行分片，目的是为了方便管理数据，这种情况也有可能缓存Key大面积失效。所以推荐过期时间加个随机时间，将过期时间随机化，避免大面积失效。

- 方法三：设置热点数据永远不过期，有更新操作直接更新缓存。

3、如果现在已经有雪崩的情况如何解决？

没有办法直接重启MySQL，直接重启又立刻被打挂。在事故中的时候，要启用本地的ehcache缓存，并且使用限流+降级的策略，直接将热点数据的请求返回，避免MySQL被打死。这个时候我们再去重启MySQL。并且修改缓存的数据，增加Key的随机失效时间，重启之后会从数据库磁盘中加载数据恢复缓存情况。

4、什么是服务熔断和服务降级？

服务熔断：当调用某个微服务不可用或者响应时间太长的时候，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务的正常响应以后，恢复调用链路。

服务降级：服务器压力很大，根据实际业务使用情况和流量，对服务页面和策略不处理或者使用简单的方式进行处理，是为了释放服务器的资源保证核心业务的正常运行。



### 缓存穿透

1、定义：缓存穿透指缓存和数据库都没有的数据，而用户不断发起请求。例如用数据库中不存在的id去请求用户信息，这个时候用户很可能是攻击者，导致数据库压力很大，严重的会击垮数据库。例如对参数不做校验，数据库id都是大于0的，用小于0的参数不断请求，绕开Redis直接打到数据库，数据库页查不到，每次都这样并发高就会导致崩溃。

2、解决方案：

- 接口层增加校验，例如用户鉴权校验，参数做校验，不合法的参数直接代码return，例如：ID基础校验，id<=0直接拦截等等。

  （开发程序必须有一个不信任的心，对于提供的API出去，作为被调用方，任何可能的参数都要考虑到，做检验，因为你不知道请求方会请求什么参数过来。例如分页查询，如果没有对分页查询的页大小限制，直接请求Integer.MAX_VALUE。一次请求耗费几秒，多几个并发就会挂了。同事调用还好，如果是黑客或者竞争对手，那就立刻出问题，例如做活动双十一发起攻击，那就麻烦了）

- Redis可以使用布隆过滤器：很好的防止缓存穿透，利用数据结构的特点，快速的判断，这个Key是否在数据库中。不存在就直接返回。存在了再去请求缓存请求数据库。

  布隆过滤器原理：当一个元素被加入集合的时候，通过k个散列函数将这个元素映射为一个位数组的k个点，将其都设置为1，检索的时候，看这k个点是不是都是1，如果都是1就知道有这个元素；如果有一个不是1为0，那么这个数据就一定不在数据库中。

  缺点：（1）存在误判：可能要查的元素不在数据库中，但是也k个位置都是1，这个时候也去查了。但是概率低，如果存的是黑名单数据，可以通过设置白名单存可能误判的元素。（2）删除困难，放入容器的元素k个位置为1，删除不能简单设置为0，因为会影响其他元素的判断。 删除可以设计为带有计数器的布隆过滤器，给每个位置对应一个计数器，如果有两个数字就对应2，这样就要用2位。如果删除就是计数器进行--。如果计数器为0，那么才为0.

  优点：布隆过滤器，用位运算的方式，存的数字比使用HashMap的方式节省空间。

- 访问key未在DB当中的时候，也将空值写入缓存，key-null形式，设置较短的时间。

- IP拉黑：可以在网关层Nginx有配置项，如果对单个IP每秒访问次数超出阈值的IP拉黑。



### 缓存击穿

1、定义：这个是数据库和缓存都是有效的数据，但是这个数据是一个热点Key。缓存击穿是这个Key非常热点，不停扛着大并发，大并发集中对这个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就好像在一个桶上击穿了一个洞。

2、解决方法：

- 设置热点数据永远不过期

- 使用互斥锁，缓存失效的时候，判断拿出来的值为空，不是立刻去加载DB，而是先用缓存的某些带成功操作返回值的操作。例如：Redis的SETNX(set if not exits) 只有不存在的时候才设置。去set一个mutex key，当操作返回成功的时候，再进行加载DB的操作并且回设缓存。否则就重试整个get缓存的方法。

  ```java
  public static String getData(String key) throws Exception {
  	// 从缓存中读取数据
      String result = getDataFromRedis(key);
      // 缓存中不存在数据
      if(result == null) {
          // 如获取锁，获取成功 去数据库读取数据
          if(reenLock.tryLock()) {
              // 从数据库获取数据
              result = getDataFromDB(key);
              // 更新缓存
              if(result != null) {
                  setDataToCache(key, result);
              }
              // 释放锁
              reenLock.unlock();
          } else {
              Thread.sleep(100);
              result = getData(key);
          }
      }
      return result
  }
  ```

  说明：

  1. 缓存有数据，就直接返回结果。
  2. 缓存没有数据，第一个进入的线程，获取锁并且从数据库去取数据，没有释放锁之前，其他并行线程等待100ms，再去重新获取数据，防止都去数据库重复读取数据，重复往缓存中更新数据的情况。
  3. 简化，如果可以根据key值去上锁更好，线程A从数据库取key1不妨碍线程B取key2的数据。