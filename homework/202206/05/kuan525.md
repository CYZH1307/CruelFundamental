### 讲讲分页、分段机制

1. #### 分段
1) 程序直接使用物理地址的问题
考虑最原始，最直接的情况，程序中访问的地址都直接对应于物理地址。
这种方式有以下几个问题：
1）两个使用的地址有交集的程序没法同时动行。
2）写代码时，必须考虑到要运行的计算机内存大小。比如说，程序要在两台机器上运行，但是一台内存为4G，一台内存为8G，那么程序最大能够使用的物理地址也就只有4G。
3）各个程序使用的内存无法进行控制。系统程序无法得到保护，各个程序之间无法隔离。

所以引入了分段机制。那么什么是分段机制呢？
将内存分成一段一段的（段大小不固定），为程序被分配某个段之后，程序便只能访问固定的段，无法访问其他地址。
而且代码中不再使用绝对地址，而是使用相对地址。当程序加载到内存中运行的时候，操作系统为程序分配合适的段。并记录段的起始地址，及界限。当程序需要访问内存中某个变量时，用段起始地址+相对地址（段内偏移地址）得到真实的物理地址。
通过这么一个机制，上面提到的直接使用物理内存的几个问题就都得到了解决。

2) 分段机制详述
内存的分段信息由操作系统进行维护，整个系统独一份（网上找到的文章大多都说一个处理器一份，不太理解）。维护分段信息的表叫做段描述符表，英文叫做GDT（global describetor table)，里面存储的是段描述符，每个段描述符占8个字节。包含段起始地址，段界限（大小），属性。计算机有一个专门的寄存器来存储段描述符表的起始地址：GDTR。这个寄存器长48个bit，32位表示基地址，16位表示长度。
知道了段描述符表，还得知道对应表中的哪个表项，才能找到段起始地址及界面。这就需要另一个寄存器了：段选择符寄存器。段选择符寄存器长16位，13位用来存储在段描述符表中的偏移，另外3位用来存储属性。所以可以看出，GDT表长度最多只能到2^13=8192个字节。8192/8=1024b也就是1024个表项。

可以想象，对于庞大的操作系统而言，仅仅分1024个段是远远不够的。所以又设计了LDT的机制：
段选择符寄存器的3个属性位中，有一个属性位标识要访问的段描述符表项一个普通的表项，还是一个LDT。LDT和GDT一样，就是一个段描述符表，不过不是全局唯一的了。那么在LDT中，到底对应哪一个表项呢？答案是LDTR，LDTR中存储了在LDT表中的偏移。

可以看出，GDTR寄存器中的值是不需要变的。
但是段选择符寄存器，LDTR都是随着运行的程序的变化而变化的。所以保存对应程序的上下文时，需要保存对应寄存器的值。



#### 2.分页

1) 为什么需要分页？
线性地址是连续的，如果直接使用线性地址作为物理地址，那么为每个段分配的物理内存就必须是连续的物理内存。这不利用碎片化内存的利用，为内存管理增大了难度。所以引入了分页机制，将地址分为大小固定的页（一般为4096字节），按页为单位进行映射。连续的线性地址可以映射到不连续的的物理内存上。
分页的另一个优点是，当物理内存不足时，可以按页为单位将内存的内容转换到磁盘上保存起来。
如果不使用分页，则只能整个段整个段的进行转换。

2） 分页机制详述
对于4GB线性地址而言，每个页4KB，则总共可以分成1024*1024=1048576个页面。
要表示每个页面的物理地址，需要4个字节。那么总共需要4MB的空间来存储分页相关的信息。
按我的理解，基于上面讲的分段机制，所有程序是共享4GB的线性地址的，所以整个系统保存一份分页相关的信息即可。
可能是哪里理解得有点不对，实际情况貌似是程序可以独享4GB的线性地址。所以每个程序都需要维护一个分页信息。那么每个程序都要4M的空间用来存储分页信息，这是不可接受的。

所以设计了两级分页机制