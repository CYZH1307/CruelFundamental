# 说说TCP 3次握手的过程和四次挥手的过程。

## 三次握手

在不可靠的网络中要可靠的传输数据, 三次握手是理论的最小值. 三次握手的主要目的是互相交换初始序列号`seq`. 

假设`A`和`B`通信且`A`发起握手请求.

1. `A`向`B`发送请求包. 其中`SYN = 1, ACK = 0, seq = x`.
2. `B`收到`A`的请求后发送响应包, 其中`SYN = 1, ack = x + 1, seq = y`.
3. `A`对`B`的响应包做出确认, 其中`SYN = 1, seq = x, ack = y + 1`.

不用两次的原因是: 防止网络中被阻塞很久的包到达`B`, 造成虚假握手浪费`B`的资源. (此时`A`已经关闭了, `B`建立连接后`A`不发送消息.)
不用四次的原因是: `B`确认`A`的`seq`以及选择自己的`seq`发给`A`, 这两步是可以合在一起的, 减少不必要的传输.

## 四次挥手

假设`A`和`B`通信且`A`发起挥手请求.

1. `A`向`B`发送请求包, 其中`FIN = 1, seq = x`, `A`停止发送数据, 进入**FIN WAIT**状态.
2. `B`向`A`发送`FIN`确认包, 其中`ACK = 1, ack = x + 1, seq = y`, `B`进入**CLOSE WAIT**状态, 此时`B`还可以发送数据.
3. `B`继续发送数据直到数据发送完毕, 发送释放连接报文,`FIN = 1, ACK = 1, ack = x + 1, seq = u`, 此时`B`进入**LAST ACK**状态.
4. `A`收到释放连接报文后, 向`B`发送确认包, `ACK = 1, ack = u + 1, seq = x + 1`. 进入**TIME WAIT**状态, 等待`2 * MSL(最大报文存活时间)`时间后关闭连接. 

**CLOSE WAIT**的原因是: `B`可能还需向`A`发送数据, `B`无法立刻关闭写端.
**TIME WAIT** 2 * MSL的原因是: 其一是保证`B`能收到确认包, 如果包丢了, `B`因超时重复发送, `A`就能够重新发送确认包并重新计时. 其二是保证本次连接产生的包在网络中全部消失, 不要影响下一次连接.