## Java: synchronized原理？CAS原理？ volatile原理？

### synchronized原理

synchronized可以锁方法、锁代码、锁对象。

Java对象，JVM有三部分。

（1）对象头：Mark Word（标记字段），Klass Point（类型指针）

（2）实例数据：存放类的数据信息，父类信息

（3）数据填充

#### 1.6之前是重量级锁

（1）同步代码：进入方法执行关联monitor对象。monitor-enter进入当前对象monitor进入数为1，已经是这个monitor对象的时候，进入数+1，当执行完以后monitor-exit减1，直到为0，才可以被其他对象持有.

（2）同步方法：ACC_SYNCHRONIZED标志位，隐式调用monitor-enter和monitor-exit。

本质上都是对ObjectMonitor的调用过程。

#### 1.6之后进行了升级

无锁-->偏向锁-->轻量级锁-->重量级锁

（1）偏向锁：对象头的锁争夺后，对象头会指向Monitor对象的争夺，线程持有这个对象以后，标志位会修改为1，进入偏向锁，并且将争夺到锁的线程ID放入对象Mark Word中。这个过程采用CAS乐观锁。同一个线程进入的时候，虚拟机不用同步，标志位+1，不同线程进入的时候CAS失败，获取锁失败。

（2）轻量级锁：对象如果无锁（偏向锁设置被关闭时），jvm会在当前线程栈帧中建立Lock Record空间，存储对象Mark Word。在锁继续争夺时，会将Lock Record中owner指向当前对象。失败时，会判断Mard Word是指向当前线程的栈帧，是当前线程已经持有了这个对象的锁，否则被其他线程持有，进行自旋，直到达到一定次数继续升级，修改锁状态之后等待线程也阻塞。

（3）重量级锁：上面自旋失败，升级为重量级锁，和1.5时一样成为重量级锁。



### CAS原理

将查看锁的状态，如果锁是空闲的，第二步将锁设置为当前线程持有。CAS函数两步合成一条硬件指令，形成原子操作，保证不可分割。

线程在读取数据时候不加锁，在准备写回数据时，先去查询原有的值，操作的时候比较原值是否修改，如果没有修改则写回，否则会重新执行读取的流程。



### volatile原理

通过内存屏障来保证volatile修饰的对象的内存可见性。volatile写为在前后分别插入内存屏障，volatile读操作是在后面插入两个内存屏障。

volatile没有保证原子性和互斥性。适用于，某个线程多个线程共享，一个线程修改以后其他线程可以得到修改后的值（happens-before）