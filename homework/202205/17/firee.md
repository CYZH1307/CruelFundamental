### C++: STL中deque底层原理是什么？

##### 实现简介：
deque底层其实维护了一个类似于二维数组的东西
其中元素指针数组*T []有类似vector的倍增操作，这个数组双端某一端到达边界的时候会进行扩容操作
元素指针*T 则指向一块定长内存，默认为512字节，如果元素容量大于512字节则设为元素容量，小于的话会包含多个元素(比如能包含64个int)

##### 这边尝试从内存和时间效率两个角度分析一下deque
时间:
时间的运行效率和vector对齐，与之不同的是deque的push_front()是o(1)的，虽然过程略复杂，但是类二维数组的结构保证了这一点
内存:
指针数组*T []需要的内存与vector类似，应该不会多于元素总量的一定倍数
指针*T指向的内存能够动态申请和释放，这边多分配的空间不会多于2*512字节(2块*T指向的内存，没有放满)

##### 疑问：
1.指针数组*T []为什么不使用循环队列的方式实现?
用循环队列感觉更省内存，可能会增加取模的开销，不过可以预设其长度为2的倍数，用位移操作来减少开销

2.为什么其内存标准和vector好像对不齐?
如果像vector一样实现deque，底层为一个T[]数组，到边界就扩容，实现上会更为简单，也会减少一次寻址操作，主要是对内存使用的标准比较统一，而且如果用循环队列来实现，其内存的申请和释放就与vector一样(同一批操作)
又或者为什么vector不像deque一样实现，这样不用根据T的大小扩容
