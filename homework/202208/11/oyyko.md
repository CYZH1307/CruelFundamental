子程序，或者称为函数，在所有语言中都是层级调用，比如 A 调用 B，B 在执行过程中又调用了 C，C 执行完毕返回，B 执行完毕返回，最后是 A 执行完毕。

所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。

- 协程（Coroutine），是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。
- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。

引用Donald Knuth的一句话总结协程的特点：“子程序就是协程的一种特例。”

协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似 CPU 的中断。

假设由协程执行，在执行 A 的过程中，可以随时中断，去执行 B，B 也可能在执行过程中中断再去执行 A

看起来 A、B 的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核 CPU 呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

Python 对协程的支持还非常有限，用在 generator 中的 yield 可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。

C/C++ 语言本身是不能天然支持协程的。现有的 C++ 协程库均基于两种方案：利用汇编代码控制协程上下文的切换，以及利用操作系统提供的 API 来实现协程上下文切换。

一般而言，基于汇编的上下文切换要比采用系统调用的切换更加高效

**所谓的有栈，无栈并不是说这个协程运行的时候有没有栈，而是说协程之间是否存在调用栈（callbackStack）**。其实仔细一想即可，但凡是个正在运行的程序，不管你是协程也好，线程也好，怎么可能在运行的时候不使用栈空间呢，调用参数往哪搁，局部变量往哪搁。我们知道基本所有的主流语言在调用另外一个函数的时候都存在一个调用栈





## 有栈协程

很多地方又把协程称为subroutine，subroutine是什么，就是函数。上古时期的计算机科学家们早就给出了概念，**coroutine就是可以中断并恢复执行的subroutine**，从这个角度来看协程拥有调用栈并不是一个奇怪的事情。我们再来思考coroutine与subroutinue相比有什么区别，你会发现区别仅有一个，就是coroutinue可以中断并恢复，对应的操作就是yield/resume，这样看来subroutinue不过是coroutinue的一个子集罢了。也就是说把协程当做一个特殊的函数调用，有栈协程就是我们理想中协程该有的模样。

既然把其当做一个特殊的函数调用，对我们来说最严峻的挑战就是如何像切换函数一样去切换协程，难点在于除了像函数一样切换出去，还要在某种条件满足的时候切换回来，我们的做法可以是在协程内部存储自身的上下文，并在需要切换的时候把上下文切换就可以了，我们知道上下文其实本质上就是寄存器，所以保存上下文实际上就是把寄存器的值保存下来，有两种方法，一种是使用汇编，libco就使用了这种方法。还有一种是使用ucontext.h，这个封装好的库也可以帮我们完成相关工作。

我们总是只能在调用栈顶的协程运行完以后才能去执行更低一层的协程，当然，这也是典型的**非对称协程，即协程之间有明显的调用关系**

有栈协程涉及到对于寄存器的保存和修改，也涉及到对每一个协程栈（实际运行的栈）的分配。对于寄存器来说，现代寄存器基本都是上百个字节的数据，还有每一个协程的栈，如果选择了共享栈，又涉及到对栈上数据的拷贝，显然在效率上来说相比无栈协程的确是有一些损失的。



## 无栈协程

那么所谓的无栈协程是什么呢？其实**无栈协程的本质就是一个状态机（state machine）**，它可以理解为在另一个角度去看问题，即**同一协程协程的切换本质不过是指令指针寄存器的改变**

```text
struct test_coroutine {
    int i;
    int __state = 0;
    void MoveNext() {
        switch(__state) {
        case 0:
            return frist();
        case 1:
            return second();
        case 2:
        	return third();
        }
    }
    void frist() {
        i = 0;
        __state = 1;
    }
    void second() {
        i++;
        _state = 2;
    }
    void third() {
    	i--;
    }
};
```

我们可以看到相比与有栈协程中的test函数，这里把整个协程抽象成一个类，以原本需要执行切换的语句处为界限，把函数划分为几个部分，并在某一个部分执行完以后进行状态转移，在下一次调用此函数的时候就会执行下一部分，这样的话我们就完全没有必要像有栈协程那样显式的执行上下文切换了，我们只需要一个简易的调度器来调度这些函数即可。

从执行时栈的角度来看，其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值，而且**相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别**，这样也可以凸显出无栈协程的高效。



## 对称协程与非对称协程

其实对于“对称”这个名词，阐述的实际是协程之间的关系，用大白话来说就是对称协程就是说协程之间人人平等，没有谁调用谁一说，大家都是一样的，而非对称协程就是协程之间存在明显的调用关系。

简单来说就是这样：

- 对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。
- 非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。



## 独立栈

协程独立栈默认使用 128k 内存空间，简单方便，一般程序使用也足够了，但是它也有缺点：

1. 如果某个协程函数使用栈空间超过 128 k，那么内存会溢出，导致进程崩溃。（当然共享栈也会，但是没那么容易溢出。）
2. 协程独立栈虽然默认只需要 128 k 内存，但是绝大多数使用场景，内存比这个少，每个协程分配固定的资源，还是有点浪费了。
3. libco 号称支持千万级协程，如果每个协程都是独立栈，那得废多少内存



## 共享栈

基于上述独立栈的缺点，共享栈应运而生。

1. 共享栈协程，协程在创建时，被分配在**指定的**共享栈内存块上工作。
2. 当然只有正在执行的协程，才会使用共享栈，当它被（yield）切换出来后，它需要保存协程上下文：寄存器数据 + 内存数据，所以共享栈上的**使用部分**（不是整个共享栈空间）会被拷贝出来。
3. 同理新切入的协程，需要将以前保存的内存上下文，重新拷贝到共享栈上工作。
4. 内存拷贝不是必然的，因为有多个共享内存块，每个块都会被指派给多个协程，只有当相同共享栈上的协程切换才会出现内存拷贝。



- 独立栈相对简单，但废内存，容易栈溢出。
- 共享栈使用公共资源，公共资源内存空间比较大，相对安全，节省内存空间，但是协程频繁切换需要进行内存拷贝，废 CPU。
- 独立栈和共享栈的实现逻辑并不复杂，协程原理理解关键在**切换**。

