mmap 
1、实现原理

建立虚拟空间一段区域和磁盘上的文件的映射。

当访问虚拟空间中该区域时，通过 MMU，得到该区域对应的物理地址，OS 发现该区域没有数据，故产生缺页中断。OS 从磁盘中读取相应页的数据直接 copy 到物理内存中。

对于传统的 read 系统调用来说，他们需要将磁盘中的文件先 copy 到内核缓冲区中，再将该数据 copy 到用户缓冲区中。相较于 mmap ，后者节省了一次 copy ，这也就解释了为什么 mmap 相较于 read 和 write 系统调用性能较高的原因了。

普通映射和匿名映射

mmap 不仅可以映射到磁盘上的普通文件，还可以映射到匿名文件。实现方式是形参中的 fd = -1，flag = MAP_SHARED | MAP_ANON 。

对于匿名映射来说，其目的是保证该共享内存映射区只能父子进程使用，其他进程无法访问。如果需要与其他进程访问的话，需要映射到磁盘上的实际文件中。

shm 实现原理

通过相同的 key，实现了不同的进程的各自一段虚拟地址空间同时映射到某一段物理内存中的功能。



mmap 保存到实际硬盘，实际存储并没有反映到主存上。优点：储存量可以很大（多于主存）缺点：进程间读取和写入速度要比主存的要慢。

shm 保存到物理存储器（主存），实际的储存量直接反映到主存上。优点，进程间访问速度（读写）比磁盘要快；缺点，储存量不能非常大（多于主存）。

使用上看：如果分配的存储量不大，那么使用 shm；如果存储量大，那么使用 mmap。

**内存映射概念**

内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映给用户空间，对于用户空间和内核空间两者之间需要进行大量数据传输等操作的话效率是非常高的。

实现这样的映射后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页到对应的文件磁盘上，就可以完成对于文件的操作，而不需要再调用read/write等系统调用函数。同时，内核空间对于这段区域的修改也可以直接反映到用户空间，从而可以实现不同进程间的文件共享。

实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或System V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一

mmap优点共有一下几点：

**常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。**

1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。

2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。

3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。

   同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。

4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。

1、mmap是在磁盘上建立一个文件，每个进程地址空间中都会开辟出一块空间进行文件-内存的映射。
而对于shm而言，shm每个进程最终会映射到同一块物理内存。shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大。
（mmap每个进程都会有自己的内存映射区，shm是映射到同一物理内存）
2、相对于shm来说，mmap更加简单，调用更加方便，所以这也是大家都喜欢用的原因。
3、另外mmap有一个好处是当机器重启，因为mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shmget就会丢失。


 