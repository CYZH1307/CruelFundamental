分为非抢占式和抢占式。

非抢占式：如果一个任务已经开始运行了则必须把它运行完毕。

抢占式：任务可能会被打断，切换到别的任务。

### 先来先去服务算法（FCFS）

该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

### 短作业(进程)优先调度算法

短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。

### 优先权调度算法

照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。

##### 非剥夺式优先权算法

系统把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。

##### 剥夺式优先权调度算法

在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，**只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。**



Round-Robin调度算法
响应时间还能更优化，只需在最短完成时间有限的调度算法上添加一个功能：指定每个进程最多只运行一段固定的时间，调度时轮询每一个进程。也就是轮询（Round-Robin，RR）调度算法。硬件上更好实现的是间隔固定的时间周期，但硬件的“进程”无法很好划分。时间片越短，RR在响应时间上表现越好，但是时间片太短也是有问题的，因为上下文切换频繁意味着它的代价越高。时间片也不能太长，时间片越长，RR在响应时间上表现越差，交互性越差。所以需要权衡时间片的长短在允许的条件下让时间片足够长。



多级反馈队列调度算法
如果未指明进程的时间周期，此种方法较为适用。优化未知问题的场景有时候非常关键，例如CPU的分支预测、缓存算法以及进程调度等等。解决这类问题的思路就是观察历史，从历史数据中推测未来。既然是预测，自然会有预测失败的时候，而预测失败的代价可能会比正常情况下更大，所以需要不断优化预测问题的方式，并提供预测失败时的挽救手段，尽量减小代价。

(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。

(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。

(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。

如果优先级A大于B，则调度A

如果优先级A等于B，则RR调度A和B

进程刚启动时，放入最高优先级队列

进程耗尽时间片后，降低该进程的优先级（移入下一级队列）

如果在时间片内进行IO而主动放弃CPU，则保持其优先级不变


