在分布式系统中，共识算法可以让多个进程就一个值达成一致。*FLP 不可能性* 给出在完全异步的系统中，在确定的有界时间内，达成共识是不可能的。即使保证了消息传递，一个进程也不可能知道另一个进程是否宕机或者运行缓慢。

在故障检测精确性和故障快速检测二者之间的权衡，共识算法假设模型是异步的并保证安全性，而外部故障检测器可以提供有关其它进程的信息，从而保证活性。由于故障检测并不完全准确，因此可能会出现以下情况：共识算法等待检测到进程故障，或者由于错误地怀疑某个进程有故障而重新启动算法。

进程必须同意由某个参与者提议的一些值，即使几个出现故障。一个进程被认为是正确的：它没有故障，并且可以持续执行算法步骤。共识算法对于将事件按特定顺序排列并确保参与者之间的一致性很有用。使用共识，我们可以建立一个系统，使得进程从一个值转移到另一个值，同时不会丢失客户端对一个值的确定性。

从理论角度来看，共识算法有三个性质：

- 合约性：所有正常进程的决策值均相同
- 有效性：决策的值是由一个进程提出的
- 终止性：所有正确的进程最终都会做出决定，也称之为活性

三个性质的每一个都是很重要的。**合约**植根于人类对共识的理解中，词典中共识的定义中包含“一致”一词。这意味着，根据合约，不允许任何进程对结果有不同的意见。可以将其视为在特定的地点与您特定的朋友见面的合约：你们所有人都想见面，并且就活动的具体细节达成协议。

**有效**是必不可少的，如果没有它，共识可能就变得微不足道。共识算法要求所有进程就某个值达成一致。如果进程使用一些预定的任意值作为输出，而不考虑提议的值，则他们将达成一致，但是这种算法的输出是无效的，并且在实际中也是没有用的。

如果没有**终止**性质，算法将永远运行下去，而不会得出任何结论，或者将无限期等待直到宕机或者进程返回，这也不是很有用。进程必须最终达成共识，并且使得共识算法实际可行，这个过程必须很快完成。



## 原子广播

尽管通过洪泛算法可以保证消息的传递，但是并不保证任何特定的顺序传递消息。消息最终到底了目的地，但是不知道到达的时间。如果需要按顺序传递消息，必须使用原子广播（也称之为全序广播），既保证了可靠性传递也保证了全序。

一个可靠的的广播保证进程对发送的消息的消息集达成一致，而原子广播可确保它们以相同的消息顺序达成一致（即，每个目标进程的消息传递顺序均相同）。

总结一下，一个消息广播可以保证如下的两个基本性质：

- 原子性：进程必须对收到的消息集达成一致，所有未故障的进程要么会传递消息，要么不传递消息。
- 顺序：所有未故障的进程都以相同的顺序传递消息。

消息以原子方式传递：每个消息或者传递到所有进程或者没有传递，如果消息被传递，每个其它的消息排在它之前或者之后。



### Zookeeper 原子广播

最著名并且被广为人知的原子广播是 ZAB，在 Apache Zookeeper 中使用，Zookeeper 是一个分层的 K-V 存储，被用来保证事件的全序和原子传递，维护副本状态之间的一致性。

在 ZAB 中的进程可以有一个或者两个角色：领导者 和 跟随者。领导者 是一个临时角色。它通过执行算法步骤来驱动进程，将消息广播给跟随者，并建立事件顺序。为了写入新记录和执行最新值的读取，客户端连接到集群中的节点之一。 如果节点碰巧是领导者，它将处理该请求。 否则，它将请求转发给领导者。

为了保证领导者的唯一性，协议时间线被分割为纪元（epoch），用唯一的单调递增的序号类标识。在任何 epoch，只能有一个 领导者。进程从使用任何选举算法找到潜在的领导者开始，只要它选择可能性很高的进程即可。进一步的算法步骤可确保安全性，因此确定潜在的领导者更多是性能优化。前领导者的故障也可能导致潜在的领导者出现。

一旦建立了潜在的领导者，它将分三个阶段执行协议：

- 发现：准领导者了解其他所有进程已知的最新纪元，并提出一个新纪元，该纪元大于任何追随者的当前纪元。 跟随者使用前一个时期中看到的最新事务的标识符响应该纪元的提议。在此步骤之后，没有任何进程会接受较早纪元的广播提议。
- 同步：这个阶段用来从前一个领导者故障中恢复，将落后的跟随者跟上，准领导者发送消息给所有跟随者，提议将其自己作为新纪元的领导者，手机其他的确认消息。只要确认消息收到，领导者就确认了自己的地位。在这一步之后，跟随者不会再接受其他任何进程的变为本纪元的领导者。在同步期间，新的领导者保证跟随者有相同的历史记录，传送由其他早期纪元的其它领导者提交的提议。在传递任何新纪元的提议之前，这些提议需要被传递。
- 广播：一旦跟随者处于同步，活跃的消息发送就开始了。在这个阶段，领导者接受客户端的消息，建立他们的顺序，广播给跟随者：发送一个新的提议，等待跟随者多数派的应答确认，最终提交。这个过程跟两阶段提交类似，但是不存在中止：投票仅仅是确认，客户端不能对有效领导者的提议投反对票。但是领导者在错误纪元的提议不应该予以确认。广播阶段一直持续到领导者出现故障，与跟随者出现网络分区或者由于消息延迟过大而被认为故障。

## Gossip是什么

Gossip协议是一个通信协议，一种传播消息的方式，灵感来自于：瘟疫、社交网络等。使用Gossip协议的有：Redis Cluster、Consul、Apache Cassandra等。

Gossip协议基本思想就是：一个节点想要分享一些信息给网络中的其他的一些节点。于是，它**周期性**的**随机**选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。一般而言，信息会周期性的传递给N个目标节点，而不只是一个。这个N被称为**fanout**（这个单词的本意是扇出）。

### 用途

Gossip协议的主要用途就是**信息传播和扩散**：即把一些发生的事件传播到全世界。它们也被用于数据库复制，信息扩散，集群成员身份确认，故障探测等。

基于Gossip协议的一些有名的系统：Apache Cassandra，Redis（Cluster模式），Consul等。



Gossip协议执行过程：

- 种子节点周期性的散播消息 【假定把周期限定为 1 秒】。
- 被感染节点随机选择N个邻接节点散播消息【假定fan-out(扇出)设置为6，每次最多往6个节点散播】。
- 节点只接收消息不反馈结果。
- 每次散播消息都选择尚未发送过的节点进行散播。
- 收到消息的节点不再往发送节点散播：A -> B，那么B进行散播的时候，不再发给 A。

Goosip 协议的信息传播和扩散通常需要由种子节点发起。整个传播过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。

Gossip协议是一个多主协议，所有写操作可以由不同节点发起，并且同步给其他副本。Gossip内组成的网络节点都是对等节点，是非结构化网络。



