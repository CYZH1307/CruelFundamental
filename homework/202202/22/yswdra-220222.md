### C++:volatile和atomic的区别

#### atomic

atomic所定义出来的变量，实质是在对 对变量操作的行为 加锁处理，例如：

```c++
atomic_int a;
a += 10;
// 上述代码本质上形如（当然这里仅代表思想如此...)
int a;
lock();
a += 10;
unlock();
```

同时，对于atomic变量，还可以通过设置参数来设定 操作该变量 行为的乱序成度。一般来说，编译器会对一段代码进行一种优化，即只要不影响最终的结果，可以修改这段代码中的指令执行顺序。而通过对atomic变量的操作设定乱序程度，可以限制编译器对这一操作在整体中的乱序程度，例如：

```
atomic_int a;

a.store(2,memory_order_release); // a = 2;
								 // 这里第二个参数表示，不论 a=2 这个操作在整体中的顺序
								 // 怎么改变，都要满足在本线程中，所有之前的写操作完成
								 // 才能执行本操作。
```



#### volatile

volatile关键字本质是在绑定对一变量的读和用操作指令，限制编译器的优化。例如：

```c++
int a, b, c;

a = b;
c = b;  // 这两句代码，编译器优化后可能只对变量b从内存中读取一次，接下来都是操作寄存器了
		// 显然，当有另外线程对b在进行赋值的话，那么当前线程中寄存器的值就不是最新值，会
		// 产生问题。

// 若
volatile int a, b, c;

a = b;
c = b;  // 此时每次操作所使用的b，一定是刚从内存地址读出来存入寄存器中数据，而不会使用寄存器
		// 中之前所保存的数据。
```

同时需要注意的是，volatile同时也固定了编译之后的对volatile变量的操作顺序，按照源代码中的顺序执行。



#### atomic和volatile的区别

显然，volatile只是限制了汇编后指令的执行顺序，以及限制了对读指令的优化，对于多线程来说，防止使用寄存器中所保留的旧数据而非使用地址中的最新数据；而atomic是限制对变量的使用操作只能在一个线程中，不同线程对同一atomic变量的使用没有时间交集。

volatile告诉编译器这个变量在别的线程中也会用到，是会变的，不要假设它不变，用保存的值。

atomic告诉编译器这个变量在别的线程中也会用到，使用它时需要加锁。

