### 协程的实现原理？ 有栈协程和无栈协程？ 独立栈和共享栈？

#### 协程的实现原理

首先 为什么要用协程？
进程并发由于进程拥有的资源太多，创建 切换和 销毁都会占用很长时间，导致cpu很大一部分时间被用在了进程调度上
线程被称作轻量级进程，但是调度时也有比较大的额外开销，每个线程都会占用1M以上的内存空间，切换线程时需要消耗内存，恢复寄存器内容时还需要向操作系统申请或销毁资源

互联网高并发场景，为每个任务都创建一个线程不太现实，需要一种更高并发能力的东西

协程：协程是用户态线程，也是轻量级的线程，用于解决高并发场景下资源切换的开销

协程的调度：
1:1 调度
一个协程绑定一个线程，这个容易实现，但实际上没有用，掩耳盗铃
N:1调度
N个协程绑定一个线程，优点是协程能用户态切换，不会陷入内核态，非常快。但是无法利用上硬件的多核加速能力一旦某个协程阻塞，就会造成线程阻塞

M:N调度
M个协程绑定N个线程，拥有上两种模型的缺点，实现起来比较复杂。


#### go语言的携程调度
Go语言的调度器通过使用与CPU数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行开销更低的gouruntine

goruntine非常轻量级，只有几KB内存 可以在有限的内存空间支持大量的goruntine，同时goruntine是可伸缩的。

goruntine在操作系统线程基础上，实现了多对多的两级线程模型。

M个gorountine运行在N个内核线程上，内核负责对N个操作系统线程进行调度，而N个系统线程又通过goruntine调度器进行丢掉。


GPM模型 一个G的执行需要 M P支持

调度策略： 调度器核心思想尽可能避免频繁创建和销毁线程。

1. work stealing机制
当本线程无G运行时，从其它线程绑定的P窃取G，而不是销毁线程
2， hand off机制
当本县城的M因为G的系统调用阻塞式，线程释放绑定的P，把P转移给空闲的M执行

抢占：
一个goroutine最多占用CPU 10ms

全局G队列：
全局G队列有互斥锁保护，访问需要竞争，新调度器将其功能弱化，只有M无法从其它P窃取到G时，才会去全局G队列拿


G-P-M分别的作用？
P提供了相关的执行环境“Context”， M表示内核线程



### 有栈协程和无栈协程：


有栈协程：
有栈协程是指每个协程会保存单独的上下文（执行栈，寄存器等）协程的唤醒和挂起就是拷贝，切换上下文

无栈协程：
无栈协程是指单个县城内的所有协程共享同一个执行栈，协程的切换就是简单的函数返回
