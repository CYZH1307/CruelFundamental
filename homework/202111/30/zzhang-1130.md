# 11-30

### 进程、线程、协程的区别和联系：

Reference: https://zhuanlan.zhihu.com/p/344823347, https://zhuanlan.zhihu.com/p/79772089

#### 进程

- 资源分配的基本单位，
- 包括可执行的代码、打开的文件描述符、挂起的信号、进程的状态、内存地址空间、存放全局变量的数据段，以及一个或多个执行线程等

#### 线程

- 进程中活动的对象，独立调度的基本单位
- 拥有**独立的程序计数器、线程堆栈和寄存器**
- **共享内存地址空间、代码段、全局变量、打开文件集合**
- Linux中创建线程会在执行 `clone()` 的时候传递一些参数来指明需要共享的资源。

---

#### 进程线程的联系：

- 进程是资源的容器，用来把资源集中到一起，而线程是在 CPU 上被实际调度的实体对象。
- 进程中有很多task，若只有一个调度，则当某个task被阻塞，其他task就不得不到执行，因此需要更多独立调度的单元 => 这些单元就是线程
- 线程比进程更轻量，创建、撤销、切换更快。
  - 进程上下文切换开销：1. 切换页表全局目录；2.切换内核态对战；3. 切换硬件上下文 （进程恢复前必须装入寄存器的数据，如 instruction pointer, base pointer, stack pointer, cr3 (页目录基址寄存器，保存页目录表的物理地址)）；4. 刷新 TLB；系统调度器的代码执行
  - 线程上下文切换开销：在 Linux 中，并不太区分进程和线程，线程只是一种轻量级进程。他们都有自己独立的task_struct进程描述符，也都有自己独立的pid。其与普通进程的区别是可以共享同一内存地址空间、代码段、全局变量、同一打开文件集合。它们的创建方式也大致相同，都是调用 fork() 函数，然后底层执行 clone() 方法创建。

---

#### 协程

- 大量并发应使用协程，而非线程

- 用户态的轻量级线程。协程不是操作系统的机制，而是由用户程序自身控制的一种调度
- 创建开销非常小，栈空间占用只有2k~4k，在一个地址空间中可以运行 10w 级别的协程。
- 相比于进程和线程的上下文切换，协程几乎没有切换的开销，因为协程的调度完全由用户程序控制，只需要保存任务的上下文，不涉及内核资源的保存和恢复。

- 在 Go 语言中，协程的栈数量可以动态伸缩，不会出现栈溢出，当一个协程结束时会自动释放，不需要垃圾回收器管理。多个协程之间的同步是通过 channel 实现的，可以保证协程执行的顺序，因此不需要锁机制就可以实现安全的并发。



### 一个进程可以创建多少线程，和什么有关：

Refernce: https://zhuanlan.zhihu.com/p/387673151

相关因素有2个：

- 进程的虚拟内存空间上限

  - 因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多

- 系统参数限制

  - 虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数

    

一些实验小结 from the above reference:

- 32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 3G/100M = 300 个左右的线程。
- 64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。
  - `/proc/sys/kernel/threads-max` 表示系统支持的最大线程数，默认值是 `14553`
  - `/proc/sys/kernel/pid_max` 表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 `32768`
  - `/proc/sys/vm/max_map_count` 表示限制一个进程可以拥有的VMA （虚拟内存区域）的数量，默认值是 `65530`
  - 如果把参数都改足够大，就取决于CPU性能。

- 对64位系统实验的follow-up:
  - 为什么物理内存只有 2G，进程的虚拟内存却可以使用 25T 呢？
    - 因为虚拟内存并不是全部都映射到物理内存的，程序是有**局部性的特性**，也就是某一个时间只会执行部分代码，所以只需要映射这部分程序就好。可以从实验看到，虽然进程虚拟空间很大，但是物理内存（RES）只有使用了 400M+。



### 外中断和异常有什么区别：

Reference: https://zhuanlan.zhihu.com/p/342248253

中断：

- 来自处理器之外的中断信号，包括时钟中断、键盘中断、它机中断和外部设备中断
- 分为可屏蔽中断和不可屏蔽中断
- 各个中断具有不同的优先级，表示事件的紧急程度，在处理高一级中断时往往会部分或全部屏蔽低级中断



异常：

- 来自处理器内部的中断信号，通常是由于在程序执行过程中，发现与当前指令关联的、不正常的或错误的事件
- 不能被屏蔽，一旦出现必须立即予以响应并进行处理，只是处理程序运行过程中可以选择是否屏蔽其它中断或屏蔽哪些中断



| 分类               | 中断                                                         | 异常                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 产生地点           | 处理器外部，由与运行程序无关的中断信号触发，中断时间系统无法得知 | 处理器内部，CPU控制单元产生                                  |
| 能否被屏蔽         | 高优先级中断可以屏蔽低优先级中断                             | 不                                                           |
| 处理程序能否被阻塞 | 不能，处理器需要及时响应其他中断信号                         | 可以                                                         |
| CPU                | 与CPU异步                                                    | 与CPU同步，一般发生在用户态，内核态唯一发生的异常是“缺页异常” |
| 能否嵌套           | 能，一般不超过三重                                           | 大多为一重                                                   |
| 彼此之间的影响     | 中断过程中不会发生异常                                       | 异常处理过程中可能发生中断                                   |

