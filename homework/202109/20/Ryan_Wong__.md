# Redis速度快的原因 #
可从粗粒度到细粒度分6个层次来逐一说明：  
1.数据库类型：本质上Redis是KV型内存数据库，所有DDL/DML/DQL均在内存中进行，不涉及写磁盘，自然其读写比传统磁盘库高出数个数量级。  
2.通信模式：只支持单线程访问，取消了线程池的开销。每个线程在面对C/S双向多个请求时，使用了流行的epoll监听实现了非阻塞的I/O机制。  
3.存储-索引数据结构：没有像传统磁盘库那样采用B+树或AVL树来组织索引，而是使用了跳表。B+树的广泛应用在于契合磁盘访问机制，树的高度小、节点宽度大，这对内存库Redis意义不大。
至于AVL树，写数据时跳表在相比大部分常用树状结构有着明显性能优势，读数据时AVL树相对跳表的优势不明显，跳表也可以很方便实现范围读取。代价是内存利用率低下，对KV以外的模型如关系模型、图模型支持比较差。
综合来说跳表能使KV内存数据库在时间上的的读写性能最优。  
4.存储-hash索引的rehash策略：当老的ptr_htOld指向的hashtable需要rehash，采用重新开辟一块空间ptr_htNew并“蚂蚁搬家”式的rehash，避免一次过产生过多的迁移操作而影响数据库性能。
当迁移完成，销毁ptr_htOld所指向空间，ptr_htOld指向ptr_htNew。  
5.存储-GC策略：采用定期删除策略，把疑似过期的数据节点entry存入一个字典，隔一小段时间T给出更短的删除时间t_del让CPU用贪心策略尽可能多删除已过期节点。
既不会在garbage过多时让CPU陷入被GC线程占死的境地，又不会在garbage过少时浪费CPU性能。  
6.存储-变量形式：各种小优化的集合，包括但不限于：采用标记长度的方法来避免多次重复计算变量大小并防止溢出导致的卡死、底层链表等结构在数据量较小时采用连续空间存储以提升访问速度等。
