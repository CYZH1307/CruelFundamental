### TFO 是如何解决重复连接的问题的？

1 http 的 keepalive 受限于 idle 时间，据 google 的统计 (chrome 浏览器), 尽管 chrome 开启了 http 的 keepalive (chrome 是 4 分钟)，可是依然有 35% 的请求是重新发起一条连接。而三次握手会造成一个 RTT 的延迟，因此 TFO 的目标就是去除 这个延迟，在三次握手期间也能交换数据。

2 RFC793 允许在 syn 数据包中带数据，可是它要求这些数据必须当 3 次握手之后才能给应用程序，这样子做主要是两个原因，syn 带数据可能会引起 2 个问 题。第一个是有可能会有前一个连接的重复或者老的数据的连接 (syn+data 的数据)，这个其实就是三次握手的必要性所决定的。第二个就是最重要的，也 就是安全方面的，为了防止攻击。

3 而在 TFO 中是这样解决上面两个问题的，第一个问题，TFO 选择接受重复的 syn, 它的观点就是有些应用是能够容忍重复的 syn+data 的 (幂等的操 作)，也就是交给应用程序自己去判断需不需要打开 TFO。比如 http 的 query 操作 (它是幂等的). 可是比如 post 这种类型的，就不能使用 TFO， 因为它有可能会改变 server 的内容。因此 TFO 默认是关闭的，内核会提供一个接口为当前的 tcp 连接打开 TFO。为了解决第二个问题，TFO 会有一个 Fast Open Cookie (这个是 TFO 最核心的一个东西), 其实也就是一个 tag。

4 启用 TFO 的 tcp 连接也很简单，就是首先 client 会在一个请求中 (非 tfo 的)，请求一个 Fast Open Cookie (放到 tcp option 中), 然后在下次的三次握手中使用这个 cookie (这个请求就会在 3 次握手的时候交换数据).
