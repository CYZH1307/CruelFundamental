### 事务消息是否了解？场景题：比如下单清空购物车，你是如何设计？

事务消息主要解决消息生产者和消息消费者的数据一致性问题。



下单清空购物车，就是将商品加入到购物车，几件商品一起下单最后支付。中间有步骤使用到消息队列。

- 系统订单创建后，发消息给【购物车系统】，【购物车系统】将已经下单的商品从【购物车】中删除。订单系统---【消息队列A】---购物车系统----【消息队列B】---【购物车数据库】
- 去订单中心创建订单
  - 订单库中插入一条订单数据，创建订单
  - 发消息给消息内容为刚刚创建的订单
  - 【订单中心】---【创建订单】---【订单数据库】

购物车系统

上面的步骤有可能失败，需要保证购物车数据库和订单数据库的一致。

购物车系统---【消息队列B】---【购物车数据库】

失败操作较为简单，只要成功执行购物车清理以后再提交消费确认即可，如果失败，没有提交消费确认，消息队列hi自动重拾。

关键为订单系统：创建订单和发送消息两个步骤要么都成功要么都失败。

分布式事务：对若干操作进行更新，为保障数据完整性和一致性，希望这些操作要么都成功，要么都失败。更新的数据形式可以很多。



消息队列实现分布式事务：

订单系统---【1.开启事务 2.发送半消息 4.提交或者回滚】----【消息队列A】 ---【5.投递消息】---购物车系统

订单系统---【3.执行本地事务，创建订单】---订单库

订单系统在消息队列上开启一个事务，然后订单系统给消息服务器发送一个"半消息"，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的区别是：事务提交之前，对于消费者不可见。

半消息发送成功后，订单系统可以执行本地事务，在订单库中创建一条订单记录，提交订单库的数据库事务，根据本地执行结果决定是否提交还是回滚事务消息。订单创建成功，提交事务消息，失败，回滚事务消息。

第四步提交事务消息可能会失败。

Kafka是直接抛出异常让用户处理。可以在业务代码中进行重试，直到提交成功，或者删除之前创建的订单进行补偿。

RocketMQ增加了事务反查机制解决事务消息提交失败问题。Producer订单系统，在提交或者回滚事务消息的时候发生网络异常，RocketMQ的broker没有收到提交或者回滚的请求，Broker会定期去Producer上反查这个事务对应的本地事务状态，然后根据反查结果决定提交或者回滚这个事务。

为了支持反查机制，需要在业务代码上面增加一个反查本地事务状态的接口，告知RocketMQ本地事务是成功还是失败。

本例子反查本地事务逻辑，只需要根据消息中的订单ID，去订单库中查询订单是否存在即可，存在则提交，不存在则回滚。

反查事务不依赖消息发送方，即使是发送事务消息的订单服务结点宕机，仍然可以仍然可以通过其他订单服务结点来执行反查。

