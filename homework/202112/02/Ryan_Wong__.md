# 进程调度算法 #

    1.先来先服务算法：所有进程按就绪/到达时间戳从早到晚排列成队列，早的进程执行完/被阻塞后才会选择更晚的进程。利于长进程占比高、进程数少的场景。
    2.最短作业最优先算法：所有进程按运行时间从短到长排列，时间短的进程执行完/被阻塞后才会选择更长的进程。利于短进程占比高的场景。
    3.高响应比优先算法：每次调度时计算进程队列里所有进程的优先级: priority[i] = (runtime[i] + time_waited[i]) / runtime[i]，总体来说runtime小的短进程依然能获得较高优先机会，
        但随着时间推移，长进程的time_waited升高之后也能获得越来越高的运行的机会。
    4.时分算法：每隔一定的时间片△t，轮流执行各个进程。保证了各个进程的被服务机会均等，但上下文切换频繁，时间片太短时影响CPU效率，时间片太长则不利于短进程效率。
    5.最高优先级算法：隔一小段时间从就绪线程队列里挑选优先级最高的进程来运行。优先级可以是静态的（预先计算好所有可能的线程的优先级）、动态的（如3.）。每次切换优先级可以是抢占式的、非抢占式的。
    6.多级反馈队列调度算法：可以算是4.和5.的综合。按优先级阈值预先开辟n个队列，就绪的进程按照优先级塞入不同的队列。队列内部执行时分调度算法，优先级越高的队列里时间片△t越小。
        短进程一般优先级高，会在前面的队列用较小的△t高效优先处理完；长进程会做优先级调整切换队列，且低优先级的进程的时间片△t小，不会过多阻塞CPU性能。
