参考：https://www.zhihu.com/question/54895548



### 1

为什么难 秒杀系统难做的原因：库存只有一份，所有人会在集中的时间读和写这些数据。 例如小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。 又例如12306抢票，亦与秒杀类似，瞬时流量更甚。

常见架构 流量到了亿级别，常见站点架构如上： 1）浏览器端，最上层，会执行到一些JS代码 2）站点层，这一层会访问后端数据，拼html页面返回给浏览器 3）服务层，向上游屏蔽底层数据细节 4）数据层，最终的库存是存在这里的，mysql是一个典型

优化方向 1）将请求尽量拦截在系统上游：传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】 2）充分利用缓存：这是一个典型的读多写少的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%】，非常适合使用缓存

浏览器层请求拦截 点击了“查询”按钮之后，系统那个卡呀，[进度条](https://www.zhihu.com/search?q=进度条&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A146924420})涨的慢呀，作为用户，我会不自觉的再去点击“查询”，继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载（一个用户点5次，80%的请求是这么多出来的），怎么整？ a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求 b）JS层面，限制用户在x秒之内只能提交一次请求 如此限流，80%流量已拦。

站点层请求拦截与页面缓存 浏览器层的请求拦截，只能拦住小白用户（不过这是99%的用户哟），高端的程序员根本不吃这一套，写个for循环，直接调用你后端的http请求，怎么整？ a）同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面 b）同一个item的查询，例如手机车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面 如此限流，又有99%的流量会被拦截在站点层



服务层请求拦截与数据缓存 站点层的请求拦截，只能拦住普通程序员，高级黑客，假设他控制了10w台[肉鸡](https://www.zhihu.com/search?q=肉鸡&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A146924420})（并且假设买票不需要实名认证），这下uid的限制不行了吧？怎么整？ a）大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？对于写请求，做请求队列，每次只透有限的写请求去数据层，如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完” b）对于读请求，还要我说么？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的 如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了.

### 2

秒杀问题：

高并发，超卖，恶意请求，链接暴露

### **服务单一职责：**

设计个能抗住高并发的系统，我觉得还是得**单一职责**。

什么意思呢，大家都知道现在设计都是**微服务的设计思想**，然后再用**分布式的部署方式**

也就是我们下单是有个订单服务，用户登录管理等有个用户服务等等，那为啥我们不给秒杀也开个服务，我们把秒杀的代码业务逻辑放一起。

单独给他建立一个数据库，现在的互联网架构部署都是**分库**的，一样的就是订单服务对应订单库，秒杀我们也给他建立自己的秒杀库。

至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用**explain**看看**SQL**的执行计划。（不了解的小伙伴也没事，MySQL章节我会说的）

单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（强行高可用）

**秒杀链接加盐：**

我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有**很大优势**。

我知道url了，那我通过程序不断获取最新的北京时间，可以达到**毫秒级别**的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送N次请求，搞不好你卖100个产品我全拿了。

**那这种情况怎么避免？**

简单，把**URL动态化**，就连写代码的人都不知道，你就通过MD5之类的加密算法加密随机的[字符串](https://www.zhihu.com/search?q=字符串&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A923987542})去做url，然后通过前端代码获取url后台校验才能通过。

### **Redis集群**，NGINX

按钮置灰

### **限流：**

限流这里我觉得应该分为**前端限流**和**后端限流**。

**前端限流**：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。

**后端限流**：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。

MQ

库存预热：用redis缓存











