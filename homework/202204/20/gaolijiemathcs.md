### TCP是怎么保证有序传输的，知不知道 time_wait状态，这个状态出现在什么地方，有什么用？

#### TCP保证有序传输

TCP接收方是按照滑动窗口的方式进行接收。接收的部分分为三部分，由两个指针划分。

- RCV.WND：表示接收窗口的大小，会告知发送方。
- RCV.NXT：是一个指针，指向期望从发送方发来的下一个字节的序号。

所以划分为：【#1+#2 已成功接收并确认的数据】【#3 未接收到但可以接收的数据】【#4未收到数据并且不可以接收的数据】

RCV.NXT指向【#1+#2】范围的下一个字节的序列号，#3的首个字节，为期望收到的字节。

RCV.NXT+RCV.WND偏移量指向#4的第一个字节



接收方只会按照期望对方发来的下一个字节的序号开头的报文，进行接收，并且接收的范围需要在接收窗口范围内(双方的滑动窗口会大小会协商，发送窗口会是min(接收窗口,拥塞窗口))。因此是顺序接收。

在确保有序传输的时候，发送方的滑动窗口会缓存已发送的数据。发送方对每个报文设置一个计时器，发送方会记录一个RTT(自适应的报文段往返时间)，如果计时器超时之前，收到对应的应答包，则会按照应答信息中ack的值进行移动。

#### 

#### time_wait状态出现在什么地方？

客户端向服务器端提出结束TCP连接 四次挥手。

在TCP四次挥手的时候，客户端收到服务器端的FIN报文以后，返回一个ACK报文就会进入TIME_WAIT的状态。主动关闭连接的时候才会有TIME_WAIT状态.

TIME_WAIT状态是2倍MSL：因为网络中可能存在来自服务器发送方的数据包，这些服务器发送方的数据包被客户端接收方处理后又会向服务器端对方发送响应，一来一回需要等待2倍时间。



需要TIME_WAIT状态等待2MSL：

（1）确保客户端最后一个ACK报文可以到达服务器，因为ACK可能丢失。服务器端已经FIN+ACK保存断开，客户端还没回音。服务器端会重新发送，如果出现这种情况，客户端在2MSL中会收到重传的报文，客户端才能够知道ACK报文丢失了，再次重传。

（2）防止“已经失效的连接请求报文段"重新出现在本次连接。2MSL中，可以使得本次连接中产生的所有报文段从网络中消失。这样下一次连接的时候，网络不会出现旧连接的请求报文。

