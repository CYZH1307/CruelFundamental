# 线程池原理

Reference: 美团 https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html



线程池：

- 线程池维护多个线程，等待Scheduler 分配可并发执行的任务
- 优点：降低资源消耗（重复利用已创建的thread，降低创建、销毁的开销），提高响应速度（不用等线程创建），提高线程的可管理性（线程池统一分配、调优、监控），提供更多更强大的功能（可拓展性，比如允许任务延期或定期执行）



ThreadPoolExecutor 维护线程、执行任务机制：

- 线程池运行分为两部分：任务管理、线程管理

- Producer - Consumer 模型
  - 任务管理部分作为producer，任务提交后线程池判断该任务后续的流转：1）直接申请线程执行该任务；2）缓冲到队列中等待线程执行；3）拒绝该任务
  - 线程管理部分作为consumer，被同一维护在线程池内，根据任务请求进行线程的分配，当线程执行完成任务后则会继续获取新的任务去执行，最终当线程获取不到任务时被回收。

- 线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。

  

### 生命周期管理

- 主要维护 运动状态（runState）和 线程数量（workerCount）
- 运动状态有5种：
  - RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务。
  - SHUTDOWN：关闭状态，不再接受新提交的任务，但可以继续处理阻塞队列中已保存的任务。
  - STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。
  - TIDYING：所有的任务都已终止了，workerCount（有效线程数）为0。
  - TERMINATED：在 terminated() 方法执行完后进入该状态。



### 任务执行机制

#### 任务调度

1. 检测线程池运行状态，若非RUNNING，拒绝
2. 若 workerCount < corePoolSize，创建并启动新线程来执行新任务
3. 若 workerCount >= corePoolSize
   1. 阻塞队列未满：添加任务到阻塞队列中
   2. 阻塞队列已满：
      1. workerCount < maximumPoolSize：创建并启动新线程来执行新任务
      2. workerCount >= maximumPoolSize:  拒绝并抛异常



#### 任务缓冲

阻塞队列(BlockingQueue)：

- 在队列为空时，获取元素的线程会等待队列变为非空
- 当队列满时，存储元素的线程会等待队列可用









