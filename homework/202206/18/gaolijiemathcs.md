### 谈谈你对流量控制的了解？

发送方发送数据，需要考虑接收方处理能力。否则接收方处理不过来会触发重传机制。

TCP有一种让发送方根据接收方的实际接收能力控制发送的数据量，就是流量控制。



#### 场景A分析

（1）假设：

假设客户端接收方，服务器端发送方。

接收窗口和发送窗口都为200。

两个设备传输过程中都保持相同的窗口大小。

（2）流量控制的过程：

1、客户端向服务器端放请求数据报文。

2、服务端接收到请求报文，发送确认报文和80字节数据，服务端可用窗口减小为120字节。同时SND.NXT指针向右偏移80字节，指向下次需要发送数据的字节编号。

3、客户端收到80字节，接收窗口向右移动80字节，RCV.NXT指向期望接收的下一个报文的序列号。

4、服务器端再次发送120字节，可用窗口剩余为0，服务端无法继续发送。

5、客户端收到120字节以后，接收窗口向右移动120字节，RCV.NXT向后移动120字节，发送确认报文。

6、服务器端接收到80字节确认报文，SND.UNA向右偏移80字节，可用窗口增大到80字节。

7、服务器端收到120字节确认报文，SND.UNA向右偏移120字节，可用窗口增大到200字节。

8、服务器端可以继续发送字节 以此类推。



#### 场景B分析

服务端资源紧张，操作系统减小接收缓冲区大小，程序无法及时读取缓冲数据，流量控制过程：

为避免发生包丢失的情况，TCP规定不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减小缓存，避免丢包问题。



#### 窗口关闭问题

TCP通过让接收方指明，希望从发送方接收到的数据大小（窗口大小）来进行流量控制。

如果窗口大小为0，就会组织发送方给接收方传递数据，直到窗口变为非0为止，就是窗口关闭。

窗口关闭的时候，是通过ACK报文来通知的，如果这个报文丢失了，接收方在等待发送方的数据，发送方一直在等待接收方非0的窗口通知，出现死锁情况。



解决窗口关闭的方法：TCP连接一方收到对方的零窗口通知，就启动持续计时器，如果持续计时器超时，就发送窗口探测报文，对方确认这个探测报文的时候，会给出自己现在接受窗口的大小。

- 如果窗口为0，就会重新启动持续计数器。
- 如果窗口不为0，打破死锁状态。



#### 糊涂窗口

接收方太忙，来不及取接受窗口数据，导致发送窗口越来越小，接收方腾出几个字节告诉发送方现在有几个字节的窗口，发送方会发送这几个字节，就是糊涂窗口综合征。

解决方法：

- 让接收方不通告小窗口给发送方。窗口大小小于min的时候，发送通告窗口为0，阻止发送方再发数据。接收方处理了一些数据，窗口大小大于min的时候，就可以窗口打开让发送方发送数据。
- 让发送方避免发送小数据。Nagle算法，等到窗口大小>=min或者数据大小>=min，收到之前发送的ack回报。没有满足上面的条件发送方就囤包，直到满足发送条件。如果是小数据包交互则不能用这种方法。



ref:https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA
