应该采取时间戳+用户ID的方法，比如淘宝给每笔订单加上的ID就是“当前时间戳+买家ID”。
比较流行的是Twitter公开的snowflakes算法，生成long型的64位ID，如下所示：

[0][← 41位，毫秒级时间戳，存的是当前时间戳和起始时间戳的差值 →][← 10位，工作机器ID →][← 12位，序列号 →]

优点：
1.毫秒数在高位，实现ID按时间趋势递增；
2.工作机器ID分配灵活，同ID对应多个序列号，方便实现高可用；

缺点：
1.时钟回拨问题：由于机器的时间是动态的调整的，有的机器有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现数据重复；
2.机器ID回收问题：由于ID分配灵活，需要考虑宕机之后的ID回收；
3.机器ID上限问题：1024显得小

解决缺点的一些方案：
1.i.采用等待一段时间的方式来防止回拨，若等待后还是回拨，则抛异常；
  ii.采用历史时间，不用真实时间戳，把序列号和工作机器ID调换位置，每次请求只增序列号，序列号满后时间戳+1（相当于进位），可避免回拨。
2.i.DB集中分配和回收：缓存下过期ID，每次来新请求先在过期ID列表从小到大找可用ID，找不到再找当前最大ID+1。
  ii.zookeeper式分配和回收：通过哈希和扩容机器，采用的是永久节点，节点中存储下次过期时间，客户端定时上报（设置心跳）看是否把当前ID回收。
3.snowflakes内部无解，通常采用客户端双Buffer+DB的方法。
