分布式环境下，多个进程之间竞争资源如何互斥？

现有一临界资源，对它的访问要求如下：

ⓐ占有资源的进程，在它将该资源授权其其他资源时，必须先释放该资源

ⓑ对资源的授权必须按照 提出资源请求的顺序 进行。即，若进程A先于进程B申请资源(有全序关系的保证，当然就知道请求的先后顺序了)，那么在分配资源时，应该将资源先分配给A用。

ⓒ对任何已获得资源的进程，最终会释放资源；也即，任何进程发生的 申请资源的请求最终会被响应。换句话说，占有资源的进程最终会使用完该资源并释放（不会死锁），这样就保证了任何资源请求最终会被响应。

如何解决该问题呢？

Lamport 大师提出了一个算法如下：

❶若要请求资源，进程Pi需要发送一个格式为 Tm:pi 的请求消息给系统中的其他所有进程，并将该消息放入自己的请求队列中。（Tm表示消息的时间戳）

❷当其他进程如Pj收到 Tm:pi请求后，将它放到自己的请求队列中，并发送一个带有时间戳的确认给pi。

❸释放资源时，pi从自己的消息队列中删除所有的 Tm:pi请求，并向其他所有的进程发送带有时间戳的 pi资源释放消息。

❹当其他进程，如pj收到pi的资源释放消息时，pj从自己的消息队列中删除所有的 Tm:pi请求消息。

❺若同时满足如下两个条件，则将资源分配给进程pi：

a)按照 全序 关系 排序后， Tm:pi请求 排在它的请求队列的最前面---即，在进程pi中， Tm:pi资源请求消息是最先 发生的。

b)pi 收到了所有其他进程发给它的时间戳大于Tm的消息



既然物理时钟不可靠，那就人为构造一个递增的序列来为事件排序，这就是Lamport逻辑时钟的基本思想。

首先需要定义先后关系(happened before)，我把事件 a 发生在 b 之前定义为 a → b。以下三种条件都满足 a → b:

1. a和b是同一个进程内的事件，a发生在b之前，则 a → b。
2. a和b在不同的进程中，a是发送进程内的发送事件，b是同一消息接收进程内的接收事件，则 a → b。
3. 如果a → b并且b → c，则a → c。

如果a和b没有先后关系，则称两个事件是并发的，记作 a || b。



我们引入逻辑时钟算法：

分布式系统中每个进程Pi保存一个本地逻辑时钟值Ci，Ci (a) 表示进程Pi发生事件a时的逻辑时钟值，Ci的更新算法如下：

1. 进程Pi每发生一次事件，Ci加1。
2. 进程Pi给进程Pj发送消息，需要带上自己的本地逻辑时钟Ci。
3. 进程Pj接收消息，更新Cj为 max (Ci, Cj) + 1。

由以上两个结论又可以得出，**对于任意两个事件a和b，如果 a → b，那么 C (a) < C (b)**。

问题来了，如果 C (a) < C (b)，那么可以得出 a → b 吗？不能。

