### mutex的实现和局限性

------

mutex即互斥含义，在概念上就是为了保证在多线程环境中只有一个线程可以持有这个锁，以防止在相对同一时间内，出现访问同一资源的情况（主要是防止流程交叉导致出现异常情况）。

##### 实现

先要判断该锁有没有被其他线程所占有，若没有被占有的话，则会设置锁中的标志位，若已被占用，则会进入等待。

这里第一点要注意的是，判断有无被占用和置位操作（如果有的话）就一定是绑在一起的原子操作，否则就可能会产生多个线程同时去置位一把锁的情况。

同时，对于等待的实现，一般是以睡眠当前线程，将自身加入锁的等待队列的方式实现，但现有为了优化其性能，会针对占有锁的线程的运行状态去更换等待方式，若占有锁的线程正在运行，则会以乐观的态度原地自旋等待。

##### 局限性

临界区内的代码的复杂度不同，会导致需要短时间内频繁访问的操作被执行需要大量时间的访问所阻塞。

即使对数据不修改也需要持有锁，这就导致读操作数量远大于写操作数量的时候，性能会十分低下。

mutex本身也就是个君子协议，也就是即使你做了加锁操作，依然可以在他出无视mutex的约束去直接访问数据。