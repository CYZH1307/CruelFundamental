# 简述 select, poll, epoll

都是I/O多路复用的机制，一个进程可以监视多个文件描述符(fd, file descriptor)，一旦某个fd ready（write or read），能够通知程序进行相应的操作。

### select

- 将`fd_set`从用户空间拷贝到内核空间，并注册回调函数， 在内核态空间来判断每个请求是否准备好数据
- 在没有查询到有fd就绪的情况下，将一直阻塞。
- 如果有一个或者多个fd就绪，那么将fd set全部返回，由程序遍历查看哪个请求有数据。

缺陷：

- 每次调用，都需要把fd set从用户态拷贝到内核态，开销大。
- 每次调用都需要在内核遍历传递进来的所有fd，在fd多时开销大
- 最大fd连接数有限，默认是1024。



### poll

- 和select非常相似，只是描述fd set的方式不同，poll使用`pollfd`结构代替select的`fd_set`，突破了Select机制中的文件描述符数量最大为1024的限制。

缺陷：除了文件描述符数量限制缺陷解决了，其他和select一样。

- 每次调用，都需要把fd集合从用户态拷贝到内核态，开销大。

- 每次调用都需要在内核遍历传递进来的所有fd，在fd多时开销大

  

### epoll  

基于事件驱动的I/O方式，没有fd个数限制；通过一个事件表直接管理用户感兴趣的所有事件。

- 使用*mmap* 内存映射方法，用户态和内核态共享fd，省去拷贝
- epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入**就绪链表**中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。
- 只关心**就绪的fd**（Poll需要关心所有fd），在连接较多的场景下，效率更高。

