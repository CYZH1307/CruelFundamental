### 简述epoll 和 poll, select 的区别

#### 1、select

select是操作系统提供的系统调用函数，使用该函数，我们可以将一个文件描述符数组(fd数组)发给操作系统，然后让操作系统确定哪个文件描述符可以读写，然后告诉我们去处理。

select为系统阻塞调用，特点如下：

(1)select 调用需要传入fd数组，需要拷贝一份到系统内核，高并发场景下拷贝的消耗很大。(可以优化为不复制)

(2)select在系统内核层仍然是通过遍历的方式去检查文件描述符数组中每个文件描述符的状态，是一个同步的过程，只不过不需要系统切换上下文，用户层需要同步等待内核层遍历。(可以优化内核层为异步事件通知方式)

(3)select使用时，内核层仅仅可以返回可读的文件描述符个数，具体哪个可读需要用户得到数字后，自己重新遍历一遍本地的文件描述符数组。（可以优化为返回用户就绪的文件描述符，无需重新遍历）

#### 2、poll

poll也是操作系统提供的系统调用函数，和select的区别，去掉了select只能监听1024个文件描述符的长度限制。

#### 3、epoll

epoll解决了select与poll中的一些问题。(主要是针对三个特点进行改进)：

(1)内核中保存了一份文件描述符集合，不需要用户每次都重新传入文件描述符，用户层只需要告诉内核文件描述符数组被修改的部分即可。并且内核中保存的文件描述符集合优化为了红黑树的结构。

(2)内核不再通过不断轮询的方式找到就绪的文件描述符，而是通过异步IO事件的方式，等待有数据到达，文件描述符触发内核IO事件异步唤醒。

(3)内核仅会将有IO事件的文件描述符返回给用户，用户不需要遍历整个文件描述符集合。

```
// 创建epoll句柄
int epoll_create(int size);
// 向内核添加、修改、删除需要监控的文件描述符
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// 用户请求IO数据
int epoll_wait(int epfd, struct epoll_event *events, int max events, int timeout);
```



#### 应用场景分析

- epoll虽然比select/poll效率高一些，但是也有代价，epoll需要单独线程执行epoll_wait会有用户态和内核态的切换，如果项目中需要管理多个I/O，监听的事件较多，并且串行设备的数据接收活动不是很频繁可以采用epoll机制。
- 但是如果监听的事件较少(连接数较少)，并且大部分的时间都是活跃频繁的，总体由于连接数较少，并发量也并不高，这种select/poll比epoll高效，因为这些socket IO事件连接数少，并发量不高，epoll会有更多次的系统调用并且红黑树的维护效率也不如数组，并且epoll系统调用涉及用户态和内核态切换频繁。
- select:每次都需要遍历这个数组，效率会随着文件描述数组增大而明显变慢。并且使用的时候需要操作将数组复制到内核态，会使得连接数的增加，效率降低。





### io 多路复用原理，在 redis 和 mysql 的实现

#### io多路复用原理

最开始的时候使用read函数 操作系统提供的函数，是阻塞IO。

后来为了主线程不卡住。操作系统提供了非阻塞的read，这样可以在一个用户态线程中读取多个文件描述符，是非阻塞IO。

但是多个文件文件描述符读取需要遍历，高并发场景下，用户态遍历的文件描述符越来越多，相当于在while当中进行越来越多的系统调用。

操作系统在内核层，增加了提供遍历文件描述符的机制，就是**IO多路复用**。

IO多路复用有三个函数，select最开始，poll解决select文件描述符长度限制问题，epoll解决了select的三个不足之处。

#### redis中的实现

redis会依照环境当中提供的函数来实现io多路复用，如果没有可选的，就使用select。

Redis会优先找有没有Solaries中的evport、Linux中的epoll和maxOS中的kqueue。如果没有的话用select。

#### mysql中的实现

mysql连接的时候是采用BIO方式，为每个连接分配一个线程，似乎没有使用io多路复用。

bio为每个数据库连接分配一个线程，连接数多的时候会导致频繁线程上下文切换，cpu利用不充分，所以mysql会有连接数阈值。

io多路复用可以提升cpu的利用率，但是不能提高io速度，当服务器的瓶颈是大量线程切换的时候io多路复用才有用，所以web的适合io多路复用。但是连接数少的时候就没必要用多路复用。而mysql这类数据库，是io密集型，瓶颈在磁盘io速度上，而不是连接数上面。

所以jdbc这类连接池，接口都是基于bio设计的。而对于数据库而言，瓶颈为磁盘IO速度，即使用NIO引入更多的客户端session，最后都会停留在磁盘IO上面，没有实际上的优化，反而会导致连接数增加，每个连接响应时长增加，对业务有不好的影响，并且数据库中行锁表锁等原因，重入的session增多，导致等待连接的市场更长，所以NIO等对DB提升没有很大。

对数据库的访问BIO+连接池已经有比较久的时间经验，基于IO的多路复用，会导致代码结构的复杂，如果有特殊需求也是可以使用IO多路复用管理Mysql连接。

redis采用IO多路复用是因为redis是内存操作，IO不是瓶颈，瓶颈是网络IO连接数，所以IO多路复用可以运用在redis上面。

