# Redis如何实现事务

Redis使用MULTI、DISCARD、EXEC、WATCH实现事务。事务能够提供将多个命令打包、一次性、按顺序的执行，并且事务在执行的时候不会主动中断，服务器执行完事务中所有命令才会继续处理其他客户端命令。

事务MULTI命令开始，接着将多个命令放入事务，最后通过EXEC来将事务提交给服务器执行。

## 事务流程

事务从开始到结束有三个阶段：事务开始->命令入队->事务执行。

### 事务开始

MULTI命令执行标志事务开始，MULTI命令可以将执行该命令的客户端从非事务状态切换到事务状态。通过在客户端状态的flags属性当中打开REDIS_MULTI标识完成。

### 命令入队

当客户端处于非事务状态，该客户端发送的命令将会立刻被服务器执行。但是当客户端切换到事务状态之后，服务器将会根据这个客户端发来的不同命令来执行不同的操作：

- 如果客户端发送MULTI、EXEC、WATCH、DISCAR命令，则会立即执行。
- 如果客户端发送上述之外，则不会立即执行，而是放入一个**事务队列**，然后想客户端返回QUEUED入队回复。

### 事务队列

Redis客户端有自己的事务状态，保存在客户端的mstate中。

- 事务状态=事务队列+事务队列长度计数器。

- 事务队列为multiCmd类型数组，保存已入队相关信息=> 实现函数指针、命令参数、参数数量。

- 事务队列满足FIFO

### 执行事务

处于事务状态客户端向服务器发送EXEC命令，EXEC命令将会被服务器执行。服务器遍历客户端的事物队列，执行队列中保存的所有命令，最后将结果全部返回给客户端。

EXEC命令流程：创建空白回复队列=>遍历事物队列中每个项(读取命令参数、参数个数、执行命令)=>对每个项执行命令返回值放入回复队列=>循环结束后移除事务标志客户端恢复非事务状态。

清空客户端事务状态，包括清零入队命令计数器、释放事务队列，并且将事务的执行结果返回客户端。



## 其他几个命令

### WATCH命令

#### 功能

WATCH命令是一个乐观锁，可以在EXEC命令执行之前监视数据库键，并且EXEC命令执行执行的时候，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器会拒绝执行事务，并且向客户端返回代表事务执行失败的空回复。

也即监视事务中的某个元素，看看其他客户端有没有在执行事务的流程中修改了事务中涉及到的元素，其他服务器修改，则事务执行失败。

#### 原理

（1）标记

将WATCH的时候，会将元素放入watched_keys字典当中，如果有人执行修改命令，执行的时候都会调用函数对watched_keys进行检查，如果有客户端正在监视刚刚被命令修改的数据库键，则会将监视的键修改的客户端的REDIS_DIRTY_CAS脏标识打开，标识事务安全性已经被破坏。

（2）判断事务安全

收到EXEC的时候，服务器会判断客户端是否打开REDIS_DIRTY_CAS。

- 如果客户端打开了REDIS_DIRTY_CAS，则客户端监视的键至少有一个被修改了，则事务不再安全，则服务器拒绝客户端提交的事务。
- 客户端没有打开REDIS_DIRTY_CAS，则客户端监视的所有键都没有修改过(也有可能客户端没有监视任何键)，事务仍然安全，则服务器执行客户端提交的事物。



### UNWATCH

取消WATCH命令对所有key的监视。可以在事务中执行。EXEC/DISCARD执行之后UNWATCH不用再执行。

### DISCARD

取消事务，放弃执行事务块内的所有命令。如果真正使用WATCH命令监视某个key，则会全部取消。

## 事务的ACID性质

Redis中，事务总是具备原子性(Atomicity)、一致性(Consisitency)和隔离性(Isolation)，当Redis运行某种持久化模式，事务也有耐久性(Durability).

### 原子性

事务的原子性指，数据库将事务中的多个操作看为一个整体执行，Redis服务器要么执行事务中的所有操作，要么就一个操作都不执行。

Redis事务和传统关系型数据库事务区别：Redis不支持事务回滚机制，事务队列中的某个命令在执行的时候出现错误，整个职务也会继续执行下去，直到事务队列中所有命令都执行完成。

### 一致性

事务的一致性指，如果数据库在执行事务之前是一致的，那么在事务执行之后，事务是否执行成功，数据库页应该一致。

此处一致定义：数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。

Redis实现了错误检测来保证事务一致性，对Redis可能出错的地方，处理错误保证事务一致性。

有入队错误、执行错误、服务器停机错误。

- 入队错误：事务入队命令，命令不存在、格式不正确等情况，Redis拒绝执行事务。
- 执行错误：事务执行过程中错误
  - 执行过程中错误，入队无法发现，命令实际执行触发错误，并被处理。
  - 事务执行过程中发生错误，服务器不中断事务执行，继续执行，并且已经执行的命令不会被出错的命令影响。
- 服务器停机：Redis服务器执行事务过程中停机，依据持久化模式进行处理
  - 无持久化内存：重启之后数据库空白，保持一致
  - RDB模式下：服务器停机，依据RDB，依据RDB文件恢复数据，如果找不到RDB文件，则数据库空白。
  - AOF模式下：事务中途停机不会不一致，服务器可以依据现有AOF文件恢复。无AOF文件，则数据库空白。

### 隔离性

事务的隔离性指，如果数据库中有多个事务并发执行，各个事务之间不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为Redis使用单线程方式执行，并且服务器保证在执行事务期间不会对事务进行中断，因此Redis事务总是以串行的方式进行运行，并且事务也总是具有隔离性。

### 耐久性

事务的耐久性指，当一个事务执行完毕的时候，执行这个事务所得到的结果已经被保存到永久存储介质当中，即使服务器在事务执行完毕后停机，执行事务所得的结果也不会丢失。

Redis事务，是用队列包裹了一组Redis命令，没有为事务提供任何额外的持久化功能，所以Redis事务的耐久性由Redis所使用的持久化模式决定。

- 当服务器在无持久化的内存运行，事务不具有耐久性：一旦服务器停机，事务数据在内的服务器数据都丢失。
- 当RDB持久化，只有特定保存条件满足，才会执行BGSAVE，对数据库保存，异步BGSAVE不能保证数据第一时间保存到硬盘中，RDB不具备耐久性。
- 当AOF持久化，当appendfsync为always时，程序总会执行命令会后调用sync函数，将命令数据真正保存到硬盘中，因此有耐久性。
- 当AOF持久化，当appendfsync为everysec时，程序1s同步一次到硬盘。停机可能正好在等待同步1秒的时候，会有失误数据丢失，不具备耐久性。
- 当AOF持久化，当appendfsync为no时，程序由操作系统决定何时数据同步。停机可能正好在等待同步的时候，会有失误数据丢失，不具备耐久性。

- 如果服务器打开no-appendfsync-on-write，即使服务器在always模式AOF下，事务也不具备耐久性。因为打开的时候，执行BGSAVE命令或者BGREWRITEAOF的时候，服务器会暂停对AOF文件的同步，减少I/O阻塞。



# 小结

- 事务提供了一种，多命令打包，一次性、有序执行机制。
- 多个命令会被入队到事务队列中，FIFO顺序执行。
- 事务在执行过程中不会被中断，当事务队列中所有命令都被执行完成，事务才会结束。
- 带有WATCH命令的事物，会将事务和被监视的键在数据库的watched_keys字典中进行关联，当键被修改的时候，程序会将所有监视被修改的客户端的REDIS_DIRTY_CAS标志打开。
- 只有在客户端的REDIS_DIRTY_CAS标志被打开的时候，服务器才会执行客户端提交的事物，否则服务器将拒绝执行客户端提交的事物。
- Redis事物总是有ACID中原子性、一致性、隔离性，而服务器运行在AOF持久化模式下，并且appendsync选项为always的时候，事物才具备耐久性。

