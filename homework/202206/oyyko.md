#### 什么是缓冲区溢出？有什么危害？



## **缓冲区溢出**

对于缓冲区溢出，一般可以分为4种类型，即栈溢出、堆溢出、BSS溢出与格式化串溢出。其中，栈溢出是最简单，也是最为常见的一种溢出方式。

### **没有保证足够的存储空间存储复制过来的数据**

```c
void function(char *str) 
{
   char buffer[10];
   strcpy(buffer,str);
}
```

上面的`strcpy()`将直接把`str`中的内容`copy`到`buffer`中。这样只要`str`的长度大于 10 ，就会造成`buffer`的溢出，使程序运行出错。存在类似`strcpy`这样的问题的标准函数还有`strcat()，sprintf()，vsprintf()，gets()，scanf()`等。对应的有更加安全的函数，即在函数名后加上`_s`，如`scanf_s()`函数。

由于内存中数据和代码相邻排列，则可以利用溢出的数据来改写可执行代码。

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

危害有以下两点：

- 程序崩溃，导致拒绝服务
- 跳转并且执行一段恶意代码

按照冯·诺依曼存储程序原理，程序代码是作为二进制数据存储在内存的，同样程序的数据也在内存中，因此直接从内存的二进制形式上是无法区分哪些是数据哪些是代码的，这也为缓冲区溢出攻击提供了可能。

每次函数调用时，系统会把函数的返回地址（函数调用指令后紧跟指令的地址），一些关键的寄存器值保存在栈内，函数的实际参数和局部变量（包括数据、结构体、对象等）也会保存在栈内。这些数据统称为函数调用的栈帧，而且是每次函数调用都会有个独立的栈帧，这也为递归函数的实现提供了可能。

之所以会有缓冲区溢出的可能，主要是因为栈空间内保存了函数的返回地址。该地址保存了函数调用结束后后续执行的指令的位置，对于计算机安全来说，该信息是很敏感的。如果有人恶意修改了这个返回地址，并使该返回地址指向了一个新的代码位置，程序便能从其它位置继续执行。



