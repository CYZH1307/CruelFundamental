系统中的每个程序都是运行在某个进程的上下文中的。

上下文是由程序正确运行所需的状态组成的，这个状态主要是存放在存储器中的程序的代码和数据、用户栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合、内核栈。

所以进程切换就是上下文切换。

通用目的寄存器
浮点寄存器
程序计数器
用户栈
状态寄存器
内核栈
各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。
其实就是整个虚拟地址空间里的东西，包括用户空间和内核空间

进程切换和线程切换的区别
最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

为什么虚拟地址空间切换会比较耗时呢？因为cache和TLB会失效

各种操作系统教材上往往会对进程、线程做出泾渭分明的定义或说明，也确实有操作系统实现了清晰的进程、线程抽象，但linux没有。linux没有为进程（process）和线程（thread）分别做抽象，而是使用一个名为task_struct的结构来描述调度的一个单元。对于那些进程拥有的公共资源，比如地址空间、打开的文件、信号等，linux分别使用相应的对象（结构体）来描述它们，例如描述进程地址空间的mm_struct。在task_struct中，不会完整的保存描述公共资源的对象，仅维护一个指向这些对象的指针。这样一来，假如两个task_struct中相应指针指向了同一个描述公共资源的对象实例，那么就说明这两个task_struct共享该公共资源，比如共享地址空间，共享打开的文件等。

体共享哪些东西是可以控制的，当我们使用clone系统调用去创建一个task_struct时，可以通过传参告诉内核新创建的任务与当前任务共享哪些资源。那么如何用task_struct去体现进程和线程呢？不难想到，假如两个task_struct不共享任何公共资源，它们就被视为两个进程；相反，如果两个task_struct共享所有公共资源，它们就被视为一个进程下的两个线程。事实上，linux中，用fork创建进程、用pthread_create创建线程，其内部都是通过调用clone，并为clone传递不共享/共享公共资源的参数来实现的，如下图：
