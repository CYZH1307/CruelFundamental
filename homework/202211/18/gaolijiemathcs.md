4次挥手。

1. 客户端发送 FIN
2. 服务器返回 ACK 号
3. 服务器发送 FIN
4. 客户端返回 ACK 号

这4步详细的来说，应该是如下：

1. **客户端发送一个FIN，用来关闭客户端到服务器的数据传送，此后客户端进入FIN_WAIT_1状态。**
2. **服务器收到FIN后，进入CLOSE_WAIT状态。正常情况下会发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），**
3. **服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。**
4. **客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成四次挥手。**

也就是说，第二步进入了CLOSE_WAIT状态，而服务器中CLOSE_WAIT状态过多说明服务器没有返回ack给客户端。检查代码发现某些地方使用完连接之后没有释放连接，修改代码之后，恢复了正常，连接进入TIME_WAIT状态，随后被系统释放。

　close_wait是被动关闭连接是形成的，根据TCP状态机，服务器端收到客户端发送的FIN，TCP协议栈会自动发送ACK，链接进入close_wait状态。但如果服务器端不执行socket的close()操作，状态就不能由close_wait迁移到last_ack，则系统中会存在很多close_wait状态的连接
关闭socket不及时：例如I/O线程被意外阻塞，或者I/O线程执行的用户自定义Task比例过高，导致I/O操作处理不及时，链路不能被及时释放。



ref:oyyko