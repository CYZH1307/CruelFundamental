#垃圾回收机制GC, cms, G1,垃圾回收的算法?

与C++自己开辟和回收内存不同，Java使用垃圾收集器来收集堆内存上的垃圾，即不再使用的对象。	java的内存通过jvm来管理，jvm使用GC（garbage collector）垃圾收集器，定期收集垃圾，释放内存。

垃圾收集器和垃圾收集算法是随着硬件内存和CPU的不断提升而不断进化出来

##垃圾收集器：

###serail ：

最早的垃圾收集器，是一个单线程的垃圾收集器，因为早起的硬件内存比较少，这个垃圾收集器适用于内存比较少的场景，是客户端的默认垃圾收集器。

###cms垃圾收集器：

concurrent mark sweep 是一个多线程并发的垃圾收集器使用的算法是标记清除算法，主要适用于计算密集型的场景，是吞吐量优先的。STW的时间相对于G1更长，因此不适用于和用户交互的场景。

###G1垃圾收集器：

garbage first 是一种适用于大内存的垃圾收集器，随着内存的不断扩大如果再使用完整的堆区域每一次STW的时间会比较长，G1将堆内存分成一个一个region，这些region分为四类，edson，survivor，old ，Humongous，前三个的大小是相同的，Humongous的大小可能是正常region的几倍，G1通过三色标记算法来标记垃圾。G1可以设置STW的时间，然后G1会尽量的达到这个目标。G1会优先收集region里面垃圾占比比较高的，这样可以快速的释放更多的内存。

##垃圾收集算法：

复制算法：适用于年轻代的一种算法，是将存活的对象复制下来，原来的区域的内存全部释放，比如年轻代的内存分配是Edson：survivor：survivor=8:1:1 ，每一次是将Edson+from suvivor的存活对象复制到to survivor，因为年轻代是朝生暮死的，存活比例是低于5%的所以用拷贝算法之拷贝存活的对象比较合适。

标记清除：老年代算法，因为老年代对象往往存活时间比较长，所以要清除的对象相对少，标记清除算法使用根可达性分析来标记存活的对象，然后将没有标记的对象进行清除，缺点是会造成内存不连续，当有大对象要进行分配内存的时候，可能没有连续的内存空间导致fullGC。

标记整理：老年代算法，解决了标记清除的不连续内存区域的问题，也是使用根可达性分析标记存活对象，然后将存活对象移动到内存区域的一个角，然后将其他的内存清理掉，这样就有了连续的内存空间。

标记压缩：还没看。。
