缓存穿透：穿透指的是透过cache直接访问数据库。 当一个key在数据库中一定不存在时也一定不存在于缓存， 但这将导致这个不存在的数据每次请求都要到存储层去查询，增大DB的负荷。 如果频繁查找不存在的数据可能会导致DB宕机
解决方法： 1. bloom filter. 将数据库可能的值通过bloom filter算法存在一个bitmap中。 2. 将查询不存在的数据也加载到缓存， 设为空。 同时将过期时间设为一个较短时间

缓存雪崩：
缓存的数据设置了非常相近的过期时间， 某时刻导致所有缓存数据失效，请求都会经过DB。 DB压力过大崩溃。
解决方案： 1. 避免失效时大量请求到数据库， 可以通过加锁或者使用队列的方式保证缓存单线程写。 2. 将数据失效时间分散。 设置失效时间时加上一个随机的值

缓存击穿：
如果缓存中某个key是非常热点的数据， 一旦过期会存在大量的并发请求到数据库。 与雪崩的区别在于击穿是针对若干热点数据而非所有数据。
解决方案： 
1. 使用mutex.缓存失效的时候不是立即load DB，而是先使用缓存的带成功操作返回值的操作设置一个mutexkey(这个key 与原要查询的key关联). 当操作返回成功时再load db. 否则等待并重试整个get缓存的方法。
当数据成功从数据库Load到缓存后删除mutexkey.
2. 永不过期。 在value中存储过期时间， 当数据快要过期的时候使用异步线程重新Load。


