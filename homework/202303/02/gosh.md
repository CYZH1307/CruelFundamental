Linux 系统是如何收发网络包的？

接收：
网卡接收网络包
通过DMA，将网络包写入到指定的内存地址（Ring Buffer）
首先进入网络接口层 检查报文合法性 不合法则丢弃 合法则找出该网络包的上层协议的类型 （IPv4 IPv6），接着去掉帧头和帧尾，然后交给网络层。
到了网络层，取出UP包，判断网络包下一步的走向，是交给上层处理还是转发出去
确认这个网络包要发送给本机后，就会从IP头里看看上一层协议的类型是TCP还是UDP，接着去掉IP头，然后交给传输层
传输层取出TCP头或UDP头，根据四元组【源IP、源端口、目的IP、目的端口】作为标识，找出对应的Socket，并把数据放到Socket的接收缓冲区。
最后，应用层程序调用Socket接口，将内核的Socket接收缓冲区的数据拷贝到应用层的缓冲区，然后唤醒用户进程

发送：
应用程序调用Socket发送数据包的接口，内核会申请一个内核态的sk_buff内存，将用户待发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区
网络协议栈从Socket发送缓冲区中取出sk_buff，并按照TCP/IP协议栈从上到下逐层处理
如果使用的是TCP，先拷贝一个新的sk_buff副本，接着对sk_buff填充TCP头。（应用层：data，TCP层：segment，IP层：packet，数据链路层：frame）
网络层：选取路由（确认下一跳的IP）、填充IP头、netfilter过滤、对超过MTU大小的数据包进行分片
网络接口层：通过ARP协议获得下一跳的MAC地址，对sk_buff填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中
触发【软中断】告诉网卡驱动程序这里有新的网络包需要发送，驱动程序会从发送队列中读取sk_buff，将这个sk_buff挂到RingBuffer中，接着将sk_buff数据映射到网卡可访问的DMA区域，最后触发真实的发送
发送完成后，网卡会出发一个硬中断来释放内存，主要是释放sk_buff内存和清理RingBuffer内存
最后，当收到这个TCP报文的ACK应答时，传输层就会释放原始的sk_buff