## go 协程如何实现

go协程和线程内核调度方式有关系。

### G-M模型

Go1.0的协程是G-M模型

- G指Goroutine，本质上是轻量级线程，包括了调用栈，重要的调度信息，例如channel
- M指Machine，一个M关联一个内核OS线程，由操作系统管理。

全局有一个Go协程队列，通过OS内核调度，内核线程M将会执行和放回对应的协程，需要访问全局G队列。

缺点：

- 存在单一全局互斥锁和集中状态。全局锁保护所有 goroutine 相关操作（如：创建、完成、重新调度等），导致锁竞争问题严重；

- goroutine 传递问题：经常在 M 之间传递“可运行”的 goroutine，这导致调度延迟增大；

- 每个线程 M 都需要做内存缓存（M.mcache），导致内存占用过高，且数据局部性较差；

- 系统调用频繁地阻塞和解除阻塞正在运行的线程，导致额外的性能损耗。




### G-P-M模型

新的协程调度器引入了P(Processor)，成为了完善的GPM模型。Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。

全局队列：存放等待运行G

P的本地队列：和全局队列类似，存放的也是等待运行的G，存放数量上限256个。新建G时，G优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半G移动到全局队列

P列表：所有的P都在程序启动时创建，保存在数组中，最多有GOMAXPROCS个，可通过runtime.GOMAXPROCS(N)修改，N表示设置的个数。

M：每个M代表一个内核线程，操作系统调度器负责把内核线程分配到CPU的核心上执行。

依据不同的调度策略：

1. work stealing机制（窃取式）：当本线程无G可运行时，从其他线程绑定的P窃取G，而不是直接销毁线程。

2. hand off机制：当本线程M1因为G进行的系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的M0执行。

|             | 数据结构                                                     | 数量                                               | 意义                   |
| ----------- | ------------------------------------------------------------ | -------------------------------------------------- | ---------------------- |
| G Goroutine | runtime.g 运行的函数指针，stack，寄存器等。                  | 每次`go func`都代表一个G，无限制                   | 代表一个用户代码执行流 |
| P Processor | runtime.p 运行G的上下文，调度器，包括mcache，runq和free g等。 | 默认为机器核数，可通过 `GOMAXPROCS` 环境变量调整。 | 表示执行所需的资源     |
| M Machine   | runtime.m 对应一个内核线程                                   | 比P多，M的最大数量可以进行设置，这个初始值是10000  | 代表执行者，底层线程   |



ref：https://juejin.cn/post/7044741465930465311



firee ref:  https://www.zhihu.com/question/20862617/answer/921061289