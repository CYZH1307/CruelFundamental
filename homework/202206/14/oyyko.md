`C P U 指令集` 有权限分级，大家试想，`C P U 指令集` 可以直接操作硬件的，要是因为指令操作的不规范\`，造成的错误会影响整个计算机系统的。好比你写程序，因为对硬件操作不熟悉，导致操作系统内核、及其他所有正在运行的程序，都可能会因为操作失误而受到不可挽回的错误，最后只能重启计算机才行。

而对于硬件的操作是非常复杂的，参数众多，出问题的几率相当大，必须谨慎的进行操作，对开发人员来说是个艰巨的任务，还会增加负担，同时开发人员在这方面也不被信任，所以操作系统内核直接屏蔽开发人员对硬件操作的可能，都不让你碰到这些 `C P U 指令集`。



用户态与内核态的概念就是C P U 指令集权限的区别，进程中要读写 `I O`，必然会用到 ring 0 级别的 `C P U 指令集`，而此时 C P U 的指令集操作权限只有 ring 3，为了可以操作ring 0 级别的 `C P U 指令集`， C P U 切换指令集操作权限级别为 ring 0，C P U再执行相应的ring 0 级别的 `C P U 指令集`（内核代码），执行的内核代码会使用当前进程的内核栈。



硬件设备商直接提供硬件级别的支持，做法就是对 `C P U 指令集`设置了权限，不同级别权限能使用的 `C P U 指令集` 是有限的，以 Inter C P U 为例，Inter把 `C P U 指令集` 操作的权限由高到低划为4级：

- ring 0
- ring 1
- ring 2
- ring 3

其中 ring 0 权限最高，可以使用所有 `C P U 指令集`，ring 3 权限最低，仅能使用常规 `C P U 指令集`，不能使用操作硬件资源的 `C P U 指令集`，比如 `I O` 读写、网卡访问、申请内存都不行，Linux系统仅采用ring 0 和 ring 3 这2个权限。

每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用



### 用户态与内核态的切换

相信大家都听过这样的话「用户态和内核态切换的开销大」，但是它的开销大在那里呢？简单点来说有下面几点

- 保留用户态现场（上下文、寄存器、用户栈等）
- 复制用户态参数，用户栈切到内核栈，进入内核态
- 额外的检查（因为内核代码对用户不信任）
- 执行内核态代码
- 复制内核态代码执行结果，回到用户态
- 恢复用户态现场（上下文、寄存器、用户栈等）

- 系统调用

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如 fork() 实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 Linux 的 int 80h 中断。

- 中断

当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

- 异常

当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常