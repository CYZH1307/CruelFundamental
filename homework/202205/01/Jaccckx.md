# 消息队列与消息队列信息丢失



### 1. 在linux中如何使用消息队列

#### 1.msgget函数

​	一个消息队列。它的原型为：
​	与其他的IPC机制一样，程序必须提供一个键来命名某个特定的消息队列。msgflg是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。msgflg可以与IPC_CREAT做或操作，表示当key所命名的消息队列不存在时创建一个消息队列，如果key所命名的消息队列存在时，IPC_CREAT标志会被忽略，而只返回一个标识符。

​	它返回一个以key命名的消息队列的标识符（非零整数），失败时返回-1.

#### 2.msgsnd函数

​	该函数用来把消息添加到消息队列中。它的原型为：
​	msgid是由msgget函数返回的消息队列标识符。

​	msg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针msg_ptr所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：

```
struct my_message{

    long int message_type; 
    
    /* The data you wish to transfer*/

};
```

​	msg_sz是msg_ptr指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说msg_sz是不包括长整型消息类型成员变量的长度。

​	msgflg用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。

​	如果调用成功，消息数据的一分副本将被放到消息队列中，并返回0，失败时返回-1.

#### 3.msgrcv函数

​	该函数用来从一个消息队列获取消息，它的原型为
msgid, msg_ptr, msg_st的作用也函数msgsnd函数的一样。

​	msgtype可以实现一种简单的接收优先级。如果msgtype为0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于msgtype的绝对值的第一个消息。

​	msgflg用于控制当队列中没有相应类型的消息可以接收时将发生的事情。

​	调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回-1.

#### 4.msgctl函数

​	该函数用来控制消息队列，它与共享内存的shmctl函数相似.
​	command是将要采取的动作，它可以取3个值，
   	 IPC_STAT：把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。
   	 IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值
 	   IPC_RMID：删除消息队列

​	buf是指向msgid_ds结构的指针，它指向消息队列模式和访问权限的结构。
### 2. 消息队列信息丢失 - RabbitMQ

#### 1）生产者丢失了数据

​			生产者将数据发送到rabbitmq的时候，可能因为网络问题导致数据在半路就给弄丢了

1. rabbitmq的事务功能（同步），生产者在发送数据之前开启rabbitmq事务(channel.txSelct)，然后发送消息，生产者阻塞等待消息队列的消息。如果消息为异常报错，此时可以回滚事务，然后重试发送消息，为正常，那么可以提交事务。但是由于同步阻塞问题，吞吐量不高
2. confirm模式：异步传送数据，每一个数据都有自己的id，出错只需回滚对应id的数据就好



#### 2) rabbitmq丢失了数据

​	为了防止rabbimq丢失数据，开启rabbitmq的持久化，写入到硬盘



#### 3)消费端弄丢了数据

​	关闭rabbitmq的自动ack机制，手动ack就好
