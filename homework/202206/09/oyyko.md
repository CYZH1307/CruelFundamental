**物理地址：**物理地址就是内存单元的绝对地址.在CPU实模式下“段基址+段内偏移地址”就是物理地址，CPU可以使用此地址直接访问内存。物理地址是内存中每个内存单元的编号，这个编号是顺序排好的，物理地址的大小决定了内存中有多少个内存单元，物理地址的大小由地址总线的位宽决定

虚拟地址：

虚拟地址是CPU保护模式下的一个概念，保护模式是80286系列和之后的x86兼容CPU操作模式，在CPU引导完操作系统内核后，操作系统内核会进入一种CPU保护模式，也叫虚拟内存管理，在这之后的程序在运行时都处于虚拟内存当中，虚拟内存里的所有地址都是不直接的，所以你有时候可以看到一个虚拟地址对应不同的物理地址，比如A进程里的call函数入口虚拟地址是0x001，而B也是，但是它俩对应的物理地址却是不同的，操作系统采用这种内存管理方法来防止程序对物理地址写数据造成一些不可必要的问题，比如知道了A进程的物理地址，那么向这个地址写入数据就会造成A进程出现问题，在虚拟内存中运行程序永远不知道自己处于内存中那一段的物理地址。

在进入虚拟模式之前CPU以及Bootloader（BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境），操作系统内核均运行在实模式下，直接对物理地址进行操作！

虚拟内存中也有分页管理，这种管理方法是为了确保内存中不会出现内存碎片，当操作系统内核初始化完毕内存中的分页表后CPU的分页标志位会被设置，这个分页标志位是给MMU看的
分页管理：

内存分页其实就是我们所说的4G空间，内存的所有内存被操作系统内核以4G为每页划分开，当我们程序运行时会被加载到内存中的4G空间里，其实说是有4G其实并没有真正在的4G空间，4G空间中有一小部分被映射到了物理内存中，或者被映射到了硬盘的文件上（fopen），或者没有被映射，还有一部分在内存当中就会被划分栈，堆，其中有大片大片的内存是没有被映射的，同样物理内存也是被分页了用来与虚拟内存产生映射关系！

其实真正情况下只有3G用户空间，假如你的内存是4G的那么其中有1G是给操作系统内核使用的。

当我们要对物理地址做操作时比如if语句要根据CPU的状态标志寄存器来做不同的跳转，那么这个时候就要对CPU额状态寄存器做操作了就必须知道它的物理地址，内存中有一个电子元件叫MMU负责从操作系统已经初始化好的内存映射表里查询与虚拟地址对应的物理地址并转换，比如mov 0x4h8这个是虚拟地址，当我们要对这个虚拟地址里写数据时那么MMU会先判断CPU的分页状态寄存器里的标志状态是否被设定，如果被设定那么MMU就会捕获这个虚拟地址物理并在操作系统内核初始化好的内存映射表里查询与之对应的物理地址，并将其转换成真正的实际物理地址，然后在对这个实际的物理地址给CPU，在由CPU去执行对应的命令，相反CPU往内存里读数据时比如A进程要读取内存中某个虚拟地址的数据，A进程里的指令给的是虚拟地址，MMU首先会检查CPU的分页状态寄存器标志位是否被设置，如果被设置MMU会捕获这个虚拟地址并将其转换成相应的物理地址然后提交给CPU，再由CPU到内存中去取数据。当我们内存中的容量不够时系统会从磁盘中分割空间出来给程序用，用换页的方式来使用。

线性地址、虚拟地址：CPU在保护模式下，“段基址+段内偏移地址”叫做线性地址，注意，保护模式下段基址寄存器中存储的不是真正的段基值（和实模式的含义不一样），而是被称为“段选择子”的东西，通过段选择子在GDT（全局描述表）中找到真正的段基值。另外，如果CPU在保护模式下没有开启分页功能，则线性地址就被当做最终的物理地址来用，若开启了分页功能，则线性地址就叫虚拟地址（在没开启分页功能的情况下线性地址和虚拟地址就是一回事）。但是，如果开启分页功能，虚拟地址（或线性地址）还要通过页部件电路转换成最终的物理地址。

**逻辑地址、有效地址：**一个逻辑地址，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为 [段标识符：段内偏移量]。

