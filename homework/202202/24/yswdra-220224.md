### C++: 简述 virtual function

------

虚函数的存在感觉是为了方便上层使用者更方便的管理和使用可以归属于同一事物的对象们，也就是说，对象的使用者（通过指针的方式使用对象）可以不用知道这个对象具体是什么，只用知道（通过指针类型）这个对象的某一归属是什么，就可以对其发号施令。

例如老板手下有一批员工，这批员工有各种各样的工种，各自干的活不一样，而老板想让全体员工开始干活，不用知道他们每人具体干什么，只要发个干活指令给他们即可（当然C++里一般是遍历worker，然后调用worker[i]->work() 实现）。



虚函数里有纯虚函数这个比较特殊的存在，纯虚函数定义时需另

```c++
virtual void func() = 0;
```

定义了纯虚函数的类，称为抽象类，抽象类无法实例对象，只有补全了虚函数定义的子类才可以实例对象。



C++通过虚函数表实现虚函数这一概念，有虚函数存在的类中，会有一个虚表指针，指向存有虚函数的表（也可以理解为一个指针数组），程序访问调用虚函数时，通过虚表指针和偏移量（函数名在对应抽象类的虚表中有固定偏移量）即可访问到对应的虚函数。 （注：通过虚表实现虚函数自然只是虚函数实现的一种方式）

每一个类的虚表在编译阶段就能确定里面的内容，因此虚表内容一般存在程序的全局数据区（或者.rodata只读段）。虚表指针的初始化在构造函数中，由编译器添加，加在构造函数的用户代码之前。

由上一段内容可以显然知道，构造函数不能为虚函数，因为一般来说必然和构造函数中初始化虚表指针这一流程冲突，当然，从更深一层来讲，使用虚函数的人不用知道这一对象指针所指之物具体是什么，而使用构造函数的人必定知道要构造出什么东西，所以构造函数从使用意义上讲也不用是虚函数。

但析构函数就需要是虚函数了，对于会被继承的类，析构函数若不是虚函数，那么在 delete 一个指针所指对象时，容易造成只释放了父类的数据，而未释放子类的数据，导致内存泄漏等问题。

