-/O多路复用

只使用一个进程来维护多个Socket

select/poll/epoll：内核提供给用户态的多路复用系统调用
进程可以通过一个系统调用函数从内核中获取多个事件

如何获取网络事件？
获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。

select/poll:
select：将以连接的Socket放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核里，让内核检查是否有网络事件产生。通过遍历来检查。
		检查到有事件产生后，将Socket标记为可读或可写，再把文件描述符集合拷贝回用户态，用户态再通过遍历找到可读或可写的Socket
poll:不再使用BitsMap表示文件描述符集合，使用动态数组（链表），突破了select的个数限制。
都使用线性结构存储进程关注的Socket集合，都需要遍历文件描述符集合来找到可读或可写的Socket，时间复杂度为O(n)，而且也需要在用户态和内核态之间拷贝文件描述符集合

epoll
先用 epoll_create() 创建一个 epol 对象， 再通过 epoll_ctl() 将需要监视的socket添加到epfd中，最后调用 epoll_wait() 等待数据

1.epoll使用红黑树来跟踪进程所有待检测的文件描述符，把需要监控的socket通过 epoll_ctl() 加入内核中的红黑树。 （增删改O(logn)） 
2.epoll使用事件驱动机制，内核里维护了一个链表来记录就绪事件，当某个socket有事件发生，内核通过回调函数将其加入这个就绪事件列表，用户调用epoll_wait()时返回

上限：系统定义的 进程能打开的最大文件描述符个数

边缘触发
监控的Socket有事件发生时，服务端只会从epoll_wait中苏醒一次

水平触发
监控的Socket有事件发生时，服务端不断地从epoll_wait中苏醒，直到内核缓冲区数据被read函数读完才结束