# 装饰器模式

该模式允许对一个已有的对象添加新的功能，但不能影响已有功能和结构。可以看做是对现有类的包装。该模式下，通常会创建一个装饰类，包含原有的类，保持原有类签名完整的前提下提供新的方法。

### 使用场景：

原有的类的功能存在改进空间，但原有类内部已经封装好的情况下、且原有类拥有相应抽象接口，使用该模式为该类增加功能。

### 优点：

1. 同样是功能扩展，装饰器模式比类继承**更灵活、更利于复用**。继承模式下，子类的所有实例都一样，要实现不同的子类只能加入多种继承关系，且这些子类相互之间独立。但装饰器模式可以把不同功能分到不同装饰器中，使用时进行动态排列组合。例如需要额外功能a或者组合型的额外功能a+b+c（a、b、c之间不耦合），继承模式的话需要写死两种继承关系，但装饰器模式可以分别实现a、b、c各自组合，且使用时还可以拼凑出b、c、a+b、b+c、a+c等不同功能。
2. 简化原有类的定义，这样按需编写相应的装饰器即可。

### 缺点：

1. 多层装饰、组合型装饰的代码较为复杂，难以维护。不像继承模式那样在面向对象语言内能得到很好维护。
2. 功能各异的装饰类互相之间若不耦合，也难以统一管理。

