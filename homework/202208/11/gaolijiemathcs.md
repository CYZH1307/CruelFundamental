### 协程的实现原理？无栈协程和有栈协程？独立栈和共享栈？

#### 协程的实现原理

当出现IO阻塞的时候，由协程的**调度器**进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由`coroutine`负责调度的线程称为`Fiber`。比如Golang里的 go关键字其实就是负责开启一个`Fiber`，让`func`逻辑跑在上面。

#### 无栈协程和有栈协程

-  有栈协程是基于函数切换上下文恢复的思路实现被中断协程的继续执行，但是这个上下文里面有返回地址，即下一条指令的地址，所以当程序发生改动重新编译生成，指令地址有可能发生改变，这种对于需要重新编译生成发布的发布场景支持并不友好，会因为程序指令地址的变化导致协程执行流的错乱。
- 无栈协程的本质就是一个`状态机（state machine）`，它可以理解为在另一个角度去看问题，即同一协程协程的切换本质不过是指令指针寄存器的改变。

#### 独立栈和共享栈

独立栈：通过独立栈实现的协程库中的每一个协程都有自己独立的栈空间，协程栈大小固定且互不干扰。

共享栈：通过共享栈实现的协程库中的每一个协程在运行时都使用一个公共的栈空间，当协程挂起时将自己的数据从共享栈拷贝到自己的独立栈，协程运行时又将数据从独立栈拷贝到共享栈运行





ref: https://www.cnblogs.com/lizhaolong/p/16437246.html

ref:https://cloud.tencent.com/developer/article/1888257

ref:https://blog.csdn.net/qq_37292982/article/details/113929423