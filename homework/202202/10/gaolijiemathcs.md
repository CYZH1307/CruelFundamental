# 什么是缓存击穿, 穿透, 雪崩? 如何解决?

### 缓存击穿

1、定义：区别于缓存雪崩为大面积的缓存失效导致打崩DB。而缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发穿破缓存，直接请求数据库，就像在一个桶底凿开了一个洞，缓存击穿。

2、解决方案：

- 设置热点数据永远不过期
- 加上互斥锁，只有获取到锁以后才能去数据库查询，查询完毕释放锁。没有拿到锁则稍后再查询。

### 缓存穿透

1、定义：(1)缓存穿透指缓存和数据库中都没有的数据，而用户不断发起请求(2)这时候用户可能为攻击者故意请求错误参数导致查询为空。两种途径查询的都是不存在的数据，导致数据库压力过大，击垮数据库。

2、例子：例如数据库id均大于0，如果一直用小于0的参数去请求，每次都能绕开Redis直接打到数据库，数据库也查不到，每次都这样导致并发高就容易崩。

3、解决方案：

- 对于缓存取不到，数据库页没有取到的数据，可以将对应的Key的Value的KV对写为null、位置错误、稍后重试等等的值。
- 看场景缓存的有效时间可以设置短一些，防止攻击用户反复用同一个id暴力攻击，正常用户不会在单秒中请求这么多次，Nginx也可以配置对IP没秒访问次数超出阈值的IP拉黑。

- 在接口层增加校验，例如用户鉴权校验，参数校验，不合法的参数直接拦截返回。开发程序过程中，要不相信任何调用方，当你提供API出去，有几个参数，对任何可能的参数情况都要考虑到，做校验要不相信任何调用你的人，因为他们行为特别，可能传任意值过去。例如接口为分页查询，没有对分页参数大小限制，几个查询Integer.MAX_VALUE并发，就会打垮数据库，因此要限制参数做校验。

- 布隆过滤器，防止缓存穿透。原理是利用高效的数据结构和算法快速判断Key在数据库中是否存在，不存在直接在redis中返回，存在再去查DB，刷新缓存KV再return。

4、布隆过滤器

（1）作用：用于判断一个元素是否出现在给定集合中，具有快速，比哈希表更节省空间等优点，缺点是存在一定的误识别概率，可能会把不是集合内的元素判定为存在于集合内。

（2）原理：S集合中有n个元素，利用k个哈希函数，将S中的每一个元素映射到一个长为m的位(bit)数组B中的不同位置上，这些位置上的二进制数均为1。如果待检测元素经过k个哈希函数的映射后，发现其k个位置哈希的二进制不全是1，那么这个元素一定不在集合S中，反之该元素有可能是S中的某一个元素。

（3）使用布隆过滤器解决缓存穿透问题：

- 使用逻辑如下

```
1.根据key查询缓存，如果存在对应的值，直接返回；如果不存在则继续执行。
2.根据key查询缓存在布隆过滤器的值，如果存在值，则说明该key不存在对应的值，直接返回空。如果不存在值，则继续向下执行。
3.查询DB对应的值，如果存在，则更新到缓存，并且返回值；如果不存在值，则更新到布隆过滤器(代表DB中不存在该值)，并且返回空。
```

- 流程图如下：

![](https://raw.githubusercontent.com/gaolijiemathcs/image-hosting/master/image-20220210180145909.png)

https://github.com/daydreamdev/MeetingFilm/blob/master/note/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.md

（4）缺点

- 存在误判，要查到元素不在容器中，但是hash之后k个位置都为1，说明有可能在容器中。例如上述bloom filter存储为黑名单，而一个元素在DB中，不应该出现在名单中，应该k位置都为0，但是出现有一个1，则被打入了黑名单。这种情况，可以建立一个白名单存储可能误判的元素。
- 删除困难，一个放入容器的元素，映射到bit数组的k位置都为1，但是删除不能直接改为0，因为可能会影响其他元素判断。可以引入Counting bloom filter(能够在BloomFilter实现删除操作，不需要重新创建布隆过滤器，阵列位置从单个位置扩展为n位计数器，常规布隆过滤器可以视为计数过滤器桶大小为1)

### 缓存雪崩

1、定义：如果同一时间Redis中的Key大面积失效，而大规模的请求直接打到数据库，数据库被打卦。

2、例子：例如电商首页的热点数据都会用缓存，一般缓存刷新都是定时任务刷新。如果所有的首页Key失效时间都是12小时，则失效刷新的时候，有个秒杀活动用户涌入，而缓存key失效，此时直接落库则会导致数据库失效。而如果打挂一个用户服务的库，会导致其他依赖库出现接口报错，如果没有做熔断策略则会瞬时挂一片，而重启数据库都会被用户打挂，出现很大问题。

3、解决方案：

- 在批量往Redis存数据的时候，将Key的失效时间都加个随机值，就可以保证数据不会在同一时间大面积失效。

  ```
  setRedis (Key, value, time + Math.random() * 10000);
  ```

- 如果Redis集群部署，则将数据库均匀分布在不同的Redis库中，也可以避免所有失效的问题。

- 也可以设置热点数据永远不过期，有更新操作就更新缓存，如果运维更新了首页商品，则刷新一下缓存，不要设置过期时间。

  

  



ref：

https://mp.weixin.qq.com/s/knz-j-m8bTg5GnKc7oeZLg

https://mp.weixin.qq.com/s/BdwZViiAqnFhCde4ZsxwPg

https://github.com/daydreamdev/MeetingFilm/blob/master/note/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.md