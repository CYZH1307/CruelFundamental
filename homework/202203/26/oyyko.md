## Docker: docker解决什么问题

为了解决软件之间的冲突，使用虚拟机的方式

类似于：

```
+-----+-----+-----+-----+
                             |App A|App B|App C|App D|
+-----+-----+-----+-----+    +-----+-----+-----+-----+
|App A|App B|App C|App D|    |Guest|Guest|Guest|Guest|
+-----+-----+-----+-----+    | OS0 | OS1 | OS2 | OS3 |
|Guest|Guest|Guest|Guest|    +-----+-----+-----+-----+
| OS0 | OS1 | OS2 | OS3 |    |        Hypervisor     |
+-----+-----+-----+-----+    +-----------------------+
|        Hypervisor     |    |         Host OS       |
+-----------------------+    +-----------------------+
|        Hardware       |    |        Hardware       |
+-----------------------+    +-----------------------+
          Type I                       Type II
```

这个时候，假如我们同时运行两个centos的guest OS，那么开两份同样的操作系统，会造成资源的浪费。

现在想要跑一个centos的底层，但是在上面跑多个互相不干扰的应用程序。应该怎么办呢?

```cpp
+-----+-----+-----+-----+                                   +-----+-----+-----+-----+
|App A|App B|App C|App D|     +-----+-----+-----+-----+     |App A|App B|App C|App D|
+-----+-----+-----+-----+     |App A|App B|App C|App D|     +-----+-----+-----+-----+
|+---------------------+|     +-----+-----+-----+-----+     |Guest|Guest|Guest|Guest|
||   Runtime Library   ||     |Lib A|Lib B|Lib C|Lib D|     | OS0 | OS1 | OS2 | OS3 |
|+---------------------+|     +-----+-----+-----+-----+     +-----+-----+-----+-----+
||       Kernel        ||     |    Container Engine   |     |        Hypervisor     |
|+---------------------+|     +-----------------------+     +-----------------------+
|   Operating System    |     |         Host OS       |     |         Host OS       |
+-----------------------+     +-----------------------+     +-----------------------+
|       Hardware        |     |        Hardware       |     |        Hardware       |
+-----------------------+     +-----------------------+     +-----------------------+
    Physical Machine                  Container                 Type II Hypervisor
```

这样，把不同的应用和运行库打包成为一个整体。



和虚拟机相比，容器有以下优点：

1. 迅速启动：没有虚拟机硬件的初始化，没有Guest OS的启动过程，可以节约很多启动时间，这就是容器的“开箱即用”。
2. 占用资源少：没有运行Guest OS所需的内存开销，无需为虚拟机预留运行内存，无需安装、运行App不需要的运行库/操作系统服务，内存占用、存储空间占用都小的多。相同配置的服务器，如果运行虚拟机只能运行十多台的，通常可以运行上百个容器毫无压力——当然前提是单个容器应用本身不会消耗太多资源。

和虚拟机相比，因为共用内核，只靠cgroup隔离，应用之间的隔离是不如虚拟机彻底的，如果某个应用运行时导致内核崩溃，所有的容器都会崩溃。而虚拟机内的应用崩溃，理论上是不会影响其它虚拟机以及上面运行的应用的，除非是硬件或者Hypervisor有Bug。

Docker可以实现：

1. 多个App可以共用相同的底层镜像（初始的操作系统镜像）
2. App运行时的IO操作和镜像文件隔离；
3. 通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个App镜像可以同时用来运行无数个不同业务的容器。

```
+---------+  +---------+  +---------+    +-----+ +-----+ +-----+
| abc.com |  | def.com |  | xyz.com |    | DB1 | | DB2 | | DB3 |    
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+    
     |            |            |            |       |       |
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+    
|   abc   |  | def.com |  | xyz.com |    | DB1 | | DB2 | | DB3 |
| config  |  | config  |  | config  |    | conf| | conf| | conf|
|  data   |  |  data   |  |  data   |    | data| | data| | data|
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+
     |            |            |            |       |       |
     +------------+------------+            +-------+-------+
                  |                                 |
           +------+------+                   +------+------+          
           | Nginx Image |                   | MySQL Image |
           +------+------+                   +------+------+
                  |                                 |
                  +----------------+----------------+
                                   |
                            +------+-------+ 
                            | Alpine Image |
                            +------+-------+
```

所以docker是一种轻量的虚拟化技术。



它出现的原因有两个：

1. 物理机器很强，算力很高
2. 在一个物理机器上跑多个服务会引起互相影响。例如一个服务的内存泄露了，其他服务会被迫中止。因此需要隔离。

之前采用虚拟机方式隔离，但是这样每一个虚拟机都需要一个操作系统内核，比较浪费资源。所以用docker来实现共享操作系统核心。



### 总结 回答问题

docker解决的问题：

1. 配置环境，不同的运行库，不同的依赖版本之间无法兼容的复杂问题。解决了运行环境和配置问题，方便发布。
2. 更高效的利用物理机器的计算资源，同时提供一定程度的隔离来方便使用。是一种轻量化的虚拟化技术。