## 请你来说一下linux内核中的Timer 定时器机制

### 定时器的实现原理

定时器的实现依赖的是CPU时钟中断，时钟中断的精度就决定定时器精度的极限。对于内核，使用特定的数据结构管理众多的定时器，在时钟中断处理中判断那些定时器超时，然后执行超时处理动作。用户控件程序不直接感知CPU时钟中断，通过感知内核的信号、IO时间、调度等间接依赖时钟中断。用软件来实现动态定时器常用的数据结构有：时间轮、最小堆和红黑树。例如
- Hierarchy时间轮算法：Linux内核
- 红黑树最小堆算法：Asio C++ Library或nginx

### Linux上定时函数
除了传统的定时函数以外，Linux上还有几个具有定时功能的API -- 多路复用。Linux上的多路复用机制有select/poll/epoll集中，它们轮询是都允许指定一个超时时间，如果指定时间内，监控事件没有到达，轮询函数就就会超时返回，精度方面，poll/epoll是毫秒级精度，而select是为妙计精度。

epoll具有天然的高并发能力，毫秒级精度通常也够用。

### 获取当前时间

适用函数有colock_gettime()，默认纳秒级精度，调用开销较大，但是可以指定参数从而粗粒度的后去时间，不需要发生上下文切换，例如指定CLOCK_REALTIME_COARSE参数后精度为毫秒级，通常够用。Time Stamp Counter是适用汇编指令获取时间戳的计数器，精度高，效率也很高，值得选择，腾讯的libco就是优先使用该方法获取时间。

### 定时器的设计

有了获取时间函数clock_gettime()和定时函数epoll之后，即可以开始设计定时器，epoll函数和其它定时通知函数一样，一次只能设置一个超时时间。主流做法是利用容器保留所有设置的超时时间，将容器里面最快超时的时间设置为epoll_wait的超时时间。若采用链表，则每次获取最快超时时间需要O(n)级别复杂度。显然我们可以用最小堆改进，事实上libevent就是这么实现的。另外由于普通的优先队列不支持删除操作，因此也可以改为使用红黑树。


### 实现

设计一个Timer类，记录回调函数以及相对系统启动后的时间（防止因设置为系统的日期时间改变后发生跳变），定时时直接将回调函数和设定时间新建一个Timer类对象，然后弄一个用户操作的接口例如TimerManager，提供增加，删除定时器的功能。addTimer()可以构造一个新的Timer对象加入红黑树中，delTimer()可以删除一个指定的Timer，getRecentTimeout可以获取一个最近的超时时间。takeAllTimeout()函数可以处理超时的定时，并回调其绑定的回调函数，由于超时的可能不止一个定时，因此需要用一个循环一一处理。
