进程间的通信方式

管道
将前一个命令的输出作为后一个命令的输入

｜：匿名管道
mkfifo myPipe：命名管道

匿名管道的创建：
系统调用：
int pipe(int fd[2])
创建一个匿名管道，返回两个描述符：管道的读取端描述符fd[0]，管道的写入端描述符fd[1]。
特殊的文件，只存在于内存，不存在于文件系统中。
管道就是内核里面的一串缓存，从管道的一端写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。管道传输的数据是无格式的流且大小受限。
如何使用这两个文件描述符进行进程间通信：
使用fork创建子进程，创建的子进程会复制父进程的文件描述符。两个进程就可以通过各自的fd写入和读取同一个管道文件实现跨进程通信了。
为了避免混乱，通常：父进程关闭读取的fd[0]，只保留写入的fd[1]；子进程关闭写入的fd[1],只保留读取的fd[0]
shell执行A|B时，A进程和B进程都是shell创建的子进程


消息队列
消息队列是保存在内核中的消息链表。每个消息体都是固定大小的存储块。进程从消息队列中读取了消息体，内核就会把这个消息体删除。
生命周期随内核 （匿名管道的生命周期随进程的创建和结束）
不足：通信不及时，大小也有限制
读取和写入的过程，都会发生用户态和内核态之间的消息拷贝过程。
共享内存解决了这个问题


共享内存
拿出一块虚拟地址空间来，映射到相同的物理内存中。


信号量
防止多进程竞争共享资源造成数据错乱，的保护机制，使得共享的资源在任意时刻只能被一个进程访问。
其实是一个整形的计数器，主要用于实现进程间的互斥与同步。

信号量表示资源的数量，控制信号量的方式有两种原子操作：
	P操作：把信号量减去1，相减后如果信号量<0，则表明资源已被占用，进程需要阻塞等待；相减后如果信号量>=0，则表明还有资源可使用，进程可正常继续执行。

	V操作：把信号量加上1，相加后如果信号量<=0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量>0，则表明当前没有阻塞中的进程。

信号量初始化为1，就代表着是互斥信号量，可以保证共享内存在任何时刻只有一个进程在访问。
信号量初始化为0，就代表着是同步信号量，可以保证进程A（生成数据后V操作）应在进程B（读取数据前P操作）之前执行。


上面的进程间通信都是 常规状态 下的工作模式。对于 异常情况 下的工作模式，就需要用信号的方式来通知进程。
信号
进程间通信机制中唯一的异步通信机制。一旦有信号产生，用户进程对信号的处理方式：
1.执行默认操作
2.捕捉信号：为信号定义一个信号处理函数。
3.忽略信号


Socket
用于跨网络与不同主机上的进程之间通信。也可以在同主机上进程间通信。

