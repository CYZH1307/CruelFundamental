# 如何保证缓存一致性
我们知道Redis常被用于热点数据的缓存以增加查询效率，但是需要保证从Redis中读取到的数据和数据库中存储的数据始终一致

客户端对数据库的操作主要分为两类:读（select）和写操作（DML）。对于读操作而言，若客户端想读取的数据在缓存中，则直接返回（缓存命中），不在redis缓存中则从数据库读入缓存（未命中缓存），因此，可以看到读操作并不会导致缓存与数据库不一致的问题。

而对于写操作，缓存和数据库中的数据都需要改变，而这两个操作不可能保证原子性，必然存在先后顺序，因此就可能导致缓存与数据库数据不一致的问题。

如此存在两个问题：
- 更新缓存or直接淘汰缓存
- 先更新缓存or先更新数据库

对于第一个问题：
   若直接将旧数据从缓存中淘汰，操作十分简单，但下次查询到该数据时会有一次缓存未命中。而更新缓存的话，若数据较为复杂，则存在多次缓存与数据库的交互，整体消耗大，另外多个线程更新缓存也存在先后性的问题，比较麻烦。相比较而言，直接从缓存中淘汰旧数据，操作简单，而且最多带来一次缓存未命中的问题，更加具有优势

对于第二个问题：

考虑先淘汰缓存，然后更新数据库：
	若采用同步更新缓存的策略，在高并发情况下，若某个线程先淘汰了缓存而数据库还未更新，此时另外一个线程到数据库中读取该数据并读入缓存，此时缓存中数据与数据库数据不一致，并且直到该数据下一次被更新均不一致，会带来很长时间的不一致问题。
	解决办法：
	1. 高并发情况下，采用异步更新策略，某个线程进行写操作，先淘汰缓存，此时其它线程读取该数据只从数据库中读而不放入缓存，等到进行写操作的线程成功更新数据库后，通过订阅binlog来异步更新缓存
	2. 若采取同步更新缓存策略，为解决长时间不一致问题，可以采用串行化或者是延时双删策略，写数据进程在完成数据库的更新后，休眠M秒后再次尝试淘汰缓存。延时双删一个是会降低更新操作的吞吐量，另一个是若二次缓存淘汰失败，还会造成长时间的不一致问题，因此还需要引入重试机制，即当二次淘汰失败，报错并继续重试，直至执行成功。

考虑先更新数据库，再淘汰缓存
	更新数据库到淘汰缓存的时间段内，数据库和缓存中的数据不一致，会造成短时间的数据不一致问题，但是此时读取效率高，此外引入重试机制可以防止淘汰缓存失败导致的数据长时间不一致问题，适用于对一致性要求不是很高的业务。

小结：
- 淘汰缓存而不是更新缓存
- 若先淘汰缓存再更新数据库，同步更新缓存策略下存在数据长时间不一致的问题，可以采用串行化或者延时双删等策略，读取效率相对高，数据一致性需要另外保证。异步更新缓存策略下，数据始终一致，但是更新时其它线程都需要到数据库中读取数据，效率低（数据一致性高，适用于对一致性要求高的业务）
- 先更新数据库再淘汰缓存，效率高，数据一段时间不一致，（适用于对一致性要求不太高的业务）

