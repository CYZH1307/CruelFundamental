Java的内存分为程序计数器， 代码区(方法区)， 数据区，堆区和栈区。栈区又分为虚拟机栈和本地方法栈。 Java虚拟机栈是线程私有的，它的生命周期与线程相同。在函数调用过程开始会创建栈用于存储局部变量，操作数，动态链接和方法返回值等。每个方法的调用过程直至执行完成的过程就对应栈帧在虚拟机入栈到出栈的过程。
程序计数器是标识当前线程执行位置的标记。每个线程对此独立，互不影响。
本地方法栈：与虚拟机栈类似，虚拟机栈主要是执行java代码编译后的字节码使用。本地方法栈是为虚拟机使用到的本地native方法服务
Java堆： 堆是可以被所有线程共享的一块区域。堆主要是为了存放对象的实例。 GC主要就是针对堆的管理。
代码区主要是存储编译后的代码，被虚拟机加载的类的信息，常量和静态变量等，这是可以被多个线程共享的。

当执行一条new指令时候，虚拟机首先检测需要创建对象的类是否已被加载到内存，解析和初始化。 只有加载到内存中虚拟机才为新对象分配内存。 选取可用内存有两种情况， 一种是用一个指针维护使用过的内存和空闲内存的边界。当需要新的内存时候就把指针往可用内存侧移动以分出一部分为使用内存。第二种方式是在JVM中维护一个内存使用列表，用来记录哪些内存是可用的，哪些是已经使用的。在分配内存的时候从列表中找出足够大的空间划分给对象使用并更新内存使用列表。 
使用第一种方式在并发的情况下会出现线程安全问题。解决方法是把内存分配操作对不同线程在不同空间进行，每个线程预先分配一小块内存(本地线程分配缓存)， 当这个缓存用完时候再通过锁的方式获取新的缓存。

Java中的对象再内存中分为三部分： 对象投， 实例数据和对齐
对象头包括对象运行时数据如哈希值，GC分代,锁标记，类型指针，如果是数组类型，还需要记录其长度。

Java堆内存分为新生代和老生代。新生代有一块较大的Eden空间和两块较小的survivor空间。对象主要在Eden区分配。当Eden没有足够空间时会发起Minor GC。 较大的对象虚拟机一般会直接分配到老年代。 这样避免在Eden区和两个survivor区发生大量的内存复制。
长期存在的对象会被放入老年代。