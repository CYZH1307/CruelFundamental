1 skiplist的复杂度和红黑树一样，而且实现起来更简单。

2 在并发环境下skiplist有另外一个优势，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。



红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在电脑科学中用到的一种数据结构，典型用途是实现关联数组。它在1972年由鲁道夫·贝尔发明，被称为"对称二叉B树"，它现代的名字源于Leo J. Guibas和罗伯特·塞奇威克于1978年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在$O(\log n)$时间内完成查找、插入和删除，这里的$n$是树中元素的数目。



红黑树是每个节点都带有*颜色*属性的[二叉查找树](https://zh.m.wikipedia.org/wiki/二元搜尋樹)，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.m.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。

这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的[二叉查找树](https://zh.m.wikipedia.org/wiki/二叉查找树)。



跳表即在有序链表之上加上索引，从而实现更快的寻址。

跳表是可以实现二分查找的有序链表；

每个元素插入时随机生成它的level；

最底层包含所有的元素；

如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；

每个索引节点包含两个指针，一个向下，一个向右；

跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；

