### 乐观锁和悲观锁，让你来写你怎么实现

#### 基本原理

- 悲观锁：对于一个共享数据的并发操作，悲观锁认为在使用数据的时候一定会有其他线程来修改数据，因此获取数据之前会先加锁，确保数据不会被其他线程修改。Java synchronized关键字和JUC的Lock都是悲观锁。
  - 悲观锁适合用于写操作多的场景，先加锁保证写操作正确。
- 乐观锁：对于一个共享数据的并发操作，乐观锁认为自己在使用数据的时候，不会有其他线程来修改数据，不添加锁，只是在更新数据的时候，回去判断之前有没有别的线程更新这个数据。如果没有数据更新，则当前线程会将修改的数据成功写入，如果数据已经被其他线程更新，则根据不同实现方式执行不同操作（如报错或者重试）。Java中乐观锁，是通过无锁编程，例如CAS算法(Java原子类的递增CAS自旋)。
  - 乐观锁适合用于读操作多的场景，不加锁读操作性能提升。



#### 实现方式

- 悲观锁：通过加锁方式实现，可以对临界区加悲观锁，例如加synchronized。ReentrantLock中可以用state标记为，值为1的时候有线程占用，其他线程需要进入同步队列等待，当获得锁的时候需要满足条件的时候，加入Condition队列，当条件满足，也加入同步队列进行获取锁的竞争。
- 乐观锁：通过实现CAS方式实现乐观锁，比较+更新。在读取数据的时候不进行加锁，等到写回数据的时候，先去查询原值，操作的时候比较原值是否修改，没有修改则写回，已被修改，则重新执行读取流程。乐观锁的问题：CPU开销、ABA问题、只能保证一个共享变量的原子操作。
  - CPU开销：CAS长时间操作不成功，会一直自旋，CPU压力大。
  - ABA问题：ABA，可能出现ABA->ACA->ABA 实际上B是被修改过的情况。解决方式：加版本号。
  - 只能保证一个共享变量的原子操作：单个共享变量可以保证原子操作，多个变量不行。解决方法：JDK5之后，AtomicReference可以用于保证对象之间的原子性，多个对象可以放入CAS中。