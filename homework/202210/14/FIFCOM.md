# tcp四次挥手过程？最后为什么等待2msls

![四次挥手](https://i.imgur.com/pkY2SjM.png)
断开一个TCP连接时，需要Client和Server总共发送4个包以确认连接的断开
1. 第一次挥手：A向B发送`FIN`包，标志位`FIN=1`，`标志位ACK=1`，发送序号`SEQ=X`，`确认序号ACK=Y`。发送后A进入`FIN_WAIT_1`状态，等待B的回应。
2. 第二次挥手：B收到`FIN`包后由其`FIN=1`可知A在请求断开连接。B将`标志位ACK`设为`1`，`确认序号ACK=X+1`，发送序号`SEQ=Y`。将确认包发给A后，B进入`CLOSE_WAIT`状态, A进入`FIN_WAIT_2`状态。
3. 第三次挥手：B也断开TCP连接，向A发送标志位`FIN=1`，`标志位ACK=1`，发送序号`SEQ=Y+1`。发送后B进入`LAST_ACK`状态。
4. 第四次挥手：客户A收到B的断开请求后，A进入`TIME_WAIT`状态并等待2MSLS，接着发送一个确认包，`标志位ACK=1`，发送序号`SEQ=X+1`，`确认序号ACK=Y+2`；B接收到后进入`CLOSED`状态

最后为什么等待2msls?

1、为了可靠地终止TCP连接：

假设第四次挥手时客户端发送的ACK报文段丢失，服务器会重发FIN报文段，这时客户端需要停留在某个状态（TIME_WAIT）以处理重复收到的FIN报文。

2、保证让迟来的TCP报文段有足够多的时间被识别并丢弃：

当一个 TCP 连接处于 TIME_WAIT 状态时，我们无法立即用该端口建立一个新连接。等待2MSL时间后网络上两个传输方向上尚未被收到的、迟到的报文段都已经消失（被中转路由器丢弃），这时新建立的连接就不会收到属于上一个连接的报文段了。