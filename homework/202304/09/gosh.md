什么是死锁，死锁的4个条件

多线程编程中，为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁。只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，一直互相等待没办法继续运行，就造成死锁。


死锁的四个条件：

互斥条件
多个线程不能同时使用同一个资源。

持有并等待条件
当线程A已经持有了资源1，又想申请资源2，而资源2已经被线程C持有了，线程A就会处于等待状态，但是线程A在等待资源2的同时并不会释放自己已经持有的资源1.

不可剥夺条件
在线程已经持有了资源，在自己使用完之前不能被其他线程获取。

环路等待条件
在死锁发生的时候，两个线程获取资源的顺序构成了环形链。


利用工具排查死锁问题
C 在 linux 下，使用 pstack + gdb 工具来定位死锁问题。
pstack命令可以显示每个线程的栈跟踪信息（函数调用过程）： pstack <pid>


避免死锁问题的发生
破坏四个条件中的一条，最常见的并且可行的就是使用资源有序分配法，来破坏环路等待条件
线程A和B用同样的顺序申请资源1和2